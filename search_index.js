var documenterSearchIndex = {"docs":
[{"location":"tutorials/performance/#Performance-Considerations","page":"Performance","title":"Performance Considerations","text":"This guide covers performance optimization techniques for OnlineStatsChains.jl.","category":"section"},{"location":"tutorials/performance/#Algorithmic-Complexity","page":"Performance","title":"Algorithmic Complexity","text":"","category":"section"},{"location":"tutorials/performance/#Core-Operations","page":"Performance","title":"Core Operations","text":"OnlineStatsChains is designed for efficiency:\n\nOperation Complexity Description\nCycle Detection O(V + E) DFS-based algorithm\nTopological Sort O(V + E) Kahn's algorithm\nPropagation O(V + E) Per update in eager mode\nAdd Node O(1) Amortized constant time\nConnect Nodes O(V + E) Includes cycle check\n\nWhere:\n\nV = number of vertices (nodes)\nE = number of edges (connections)","category":"section"},{"location":"tutorials/performance/#Memory-Usage","page":"Performance","title":"Memory Usage","text":"Memory overhead per node is minimal:\n\nNode struct: ~100 bytes\nTopological cache: O(V)\nDirty set (lazy mode): O(V)\n\nFor large graphs (1000+ nodes), memory footprint remains manageable.","category":"section"},{"location":"tutorials/performance/#Choosing-Evaluation-Strategies","page":"Performance","title":"Choosing Evaluation Strategies","text":"","category":"section"},{"location":"tutorials/performance/#Eager-Evaluation","page":"Performance","title":"Eager Evaluation","text":"Best for:\n\nReal-time processing\nSmall to medium DAGs\nStreaming data\nWhen all nodes need updates\n\nCharacteristics:\n\nImmediate propagation\nNo deferred computation\nPredictable latency\nHigher throughput for dense updates\n\ndag = StatDAG(strategy=:eager)\n# Good for: streaming sensors, real-time dashboards","category":"section"},{"location":"tutorials/performance/#Lazy-Evaluation","page":"Performance","title":"Lazy Evaluation","text":"Best for:\n\nLarge DAGs\nSparse queries\nBatch processing\nWhen only some results are needed\n\nCharacteristics:\n\nDeferred computation\nCompute only what's requested\nLower memory pressure\nBetter for selective access\n\ndag = StatDAG(strategy=:lazy)\n# Good for: large analytics pipelines, selective queries","category":"section"},{"location":"tutorials/performance/#Partial-Evaluation","page":"Performance","title":"Partial Evaluation","text":"Best for:\n\nLarge DAGs with independent branches\nWhen updates affect limited subgraphs\nAvoiding unnecessary recomputation\n\nCharacteristics:\n\nSelective propagation\nOptimized for sparse updates\nReduced computation for unchanged branches\n\ndag = StatDAG(strategy=:partial)\n# Good for: multi-branch analytics, parallel streams","category":"section"},{"location":"tutorials/performance/#Performance-Tips","page":"Performance","title":"Performance Tips","text":"","category":"section"},{"location":"tutorials/performance/#1.-Batch-Updates","page":"Performance","title":"1. Batch Updates","text":"Process data in batches when possible:\n\n# Slow - many small updates\nfor x in data\n    fit!(dag, :source => x)\nend\n\n# Fast - batch update\nfit!(dag, :source => data)\n\nSpeedup: 10-100x for large datasets","category":"section"},{"location":"tutorials/performance/#2.-Minimize-Connections","page":"Performance","title":"2. Minimize Connections","text":"Fewer edges = faster propagation:\n\n# Slower - deeply nested chain\nconnect!(dag, :a, :b)\nconnect!(dag, :b, :c)\nconnect!(dag, :c, :d)\n# ... many levels\n\n# Faster - flatter structure when possible\nconnect!(dag, :input, :output1)\nconnect!(dag, :input, :output2)","category":"section"},{"location":"tutorials/performance/#3.-Use-Lazy-for-Selective-Access","page":"Performance","title":"3. Use Lazy for Selective Access","text":"When querying only some nodes:\n\n# Eager: computes all 100 nodes\ndag = StatDAG(strategy=:eager)\nfor i in 1:100\n    add_node!(dag, Symbol(\"n\", i), Mean())\n    i > 1 && connect!(dag, Symbol(\"n\", i-1), Symbol(\"n\", i))\nend\nfit!(dag, :n1 => data)  # Updates all 100\n\n# Lazy: computes only what's needed\ndag = StatDAG(strategy=:lazy)\n# ... same structure ...\nfit!(dag, :n1 => data)  # No propagation\nvalue(dag, :n100)  # Computes only path to n100","category":"section"},{"location":"tutorials/performance/#4.-Reuse-DAGs","page":"Performance","title":"4. Reuse DAGs","text":"Creating DAGs has overhead - reuse when possible:\n\n# Initialize once\ndag = create_analysis_pipeline()\n\n# Reuse many times\nfor batch in data_stream\n    fit!(dag, :input => batch)\n    results = value(dag, :output)\nend","category":"section"},{"location":"tutorials/performance/#5.-Pre-allocate-for-Known-Patterns","page":"Performance","title":"5. Pre-allocate for Known Patterns","text":"Build DAG structure before data processing:\n\n# Good: structure first, data later\ndag = StatDAG()\nbuild_dag_structure!(dag)\n\nfor data in stream\n    fit!(dag, :input => data)\nend\n\n# Avoid: mixing structure changes with data\nfor data in stream\n    add_node!(dag, random_name(), Mean())  # Bad!\n    fit!(dag, :input => data)\nend","category":"section"},{"location":"tutorials/performance/#Benchmarking","page":"Performance","title":"Benchmarking","text":"","category":"section"},{"location":"tutorials/performance/#Measuring-Performance","page":"Performance","title":"Measuring Performance","text":"using BenchmarkTools\n\n# Create DAG\ndag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :sink, Mean())\nconnect!(dag, :source, :sink)\n\ndata = randn(1000)\n\n# Benchmark\n@benchmark fit!($dag, :source => $data)","category":"section"},{"location":"tutorials/performance/#Comparing-Strategies","page":"Performance","title":"Comparing Strategies","text":"using BenchmarkTools\n\nfunction benchmark_strategies(n_nodes::Int, data_size::Int)\n    data = randn(data_size)\n\n    for strategy in [:eager, :lazy, :partial]\n        dag = StatDAG(strategy=strategy)\n\n        # Build chain\n        for i in 1:n_nodes\n            add_node!(dag, Symbol(\"n\", i), Mean())\n            i > 1 && connect!(dag, Symbol(\"n\", i-1), Symbol(\"n\", i))\n        end\n\n        # Benchmark\n        println(\"Strategy: $strategy\")\n        @btime fit!($dag, :n1 => $data)\n        @btime value($dag, Symbol(\"n\", $n_nodes))\n    end\nend\n\nbenchmark_strategies(10, 1000)","category":"section"},{"location":"tutorials/performance/#Memory-Optimization","page":"Performance","title":"Memory Optimization","text":"","category":"section"},{"location":"tutorials/performance/#1.-Clear-Caches-Periodically","page":"Performance","title":"1. Clear Caches Periodically","text":"For long-running processes:\n\n# After processing many batches\ndag = StatDAG()\n# ... process lots of data ...\n\n# Manually trigger garbage collection if needed\nGC.gc()","category":"section"},{"location":"tutorials/performance/#2.-Lazy-for-Memory-Constrained-Environments","page":"Performance","title":"2. Lazy for Memory-Constrained Environments","text":"Lazy evaluation reduces memory pressure:\n\n# Eager: all nodes cache values\ndag_eager = StatDAG(strategy=:eager)\n\n# Lazy: only computed nodes cache\ndag_lazy = StatDAG(strategy=:lazy)\nfit!(dag_lazy, :input => data)\n# Memory used: only :input and its stat","category":"section"},{"location":"tutorials/performance/#3.-Streaming-for-Large-Datasets","page":"Performance","title":"3. Streaming for Large Datasets","text":"Process in chunks to control memory:\n\ndag = StatDAG()\nadd_node!(dag, :processor, Mean())\n\nchunk_size = 1000\nfor chunk in Iterators.partition(huge_dataset, chunk_size)\n    fit!(dag, :processor => collect(chunk))\nend","category":"section"},{"location":"tutorials/performance/#Profiling","page":"Performance","title":"Profiling","text":"Identify bottlenecks:\n\nusing Profile\n\ndag = create_complex_dag()\ndata = generate_test_data()\n\n@profile for _ in 1:100\n    fit!(dag, :input => data)\nend\n\nProfile.print()","category":"section"},{"location":"tutorials/performance/#Common-Performance-Pitfalls","page":"Performance","title":"Common Performance Pitfalls","text":"","category":"section"},{"location":"tutorials/performance/#Avoid","page":"Performance","title":"❌ Avoid","text":"# 1. Many small DAG modifications\nfor data_point in stream\n    dag = StatDAG()  # Don't recreate!\n    add_node!(dag, :temp, Mean())\n    fit!(dag, :temp => data_point)\nend\n\n# 2. Unnecessary value() calls in loops\nfor data in batches\n    fit!(dag, :input => data)\n    v = value(dag, :output)  # Don't query every iteration\nend\n\n# 3. Deep chains when parallel structure works\n# a → b → c → d → e  (slow)\n# Better: a → [b, c, d, e]  (fast)","category":"section"},{"location":"tutorials/performance/#Do","page":"Performance","title":"✅ Do","text":"# 1. Reuse DAG structure\ndag = StatDAG()\nadd_node!(dag, :processor, Mean())\n\nfor data_point in stream\n    fit!(dag, :processor => data_point)\nend\n\n# 2. Batch queries\nfor data in batches\n    fit!(dag, :input => data)\nend\nresult = value(dag, :output)  # Query once\n\n# 3. Use appropriate structure\ndag = StatDAG()\nadd_node!(dag, :input, Mean())\nfor i in 1:n\n    add_node!(dag, Symbol(\"out\", i), Mean())\n    connect!(dag, :input, Symbol(\"out\", i))\nend","category":"section"},{"location":"tutorials/performance/#Scaling-to-Large-Graphs","page":"Performance","title":"Scaling to Large Graphs","text":"","category":"section"},{"location":"tutorials/performance/#Handling-1000-Nodes","page":"Performance","title":"Handling 1000+ Nodes","text":"# Lazy evaluation is crucial\ndag = StatDAG(strategy=:lazy)\n\n# Batch node creation\nfunction build_large_dag(n::Int)\n    dag = StatDAG(strategy=:lazy)\n\n    # Add nodes efficiently\n    for i in 1:n\n        add_node!(dag, Symbol(\"n\", i), Mean())\n    end\n\n    # Add connections\n    for i in 1:n-1\n        connect!(dag, Symbol(\"n\", i), Symbol(\"n\", i+1))\n    end\n\n    return dag\nend\n\nlarge_dag = build_large_dag(5000)","category":"section"},{"location":"tutorials/performance/#Parallel-Processing-(Future)","page":"Performance","title":"Parallel Processing (Future)","text":"Current version is single-threaded. Future versions may support:\n\nParallel branch execution\nMulti-threaded propagation\nDistributed computing","category":"section"},{"location":"tutorials/performance/#Optimization-Checklist","page":"Performance","title":"Optimization Checklist","text":"[ ] Use appropriate evaluation strategy\n[ ] Batch data updates when possible\n[ ] Reuse DAG structures\n[ ] Minimize graph depth\n[ ] Profile before optimizing\n[ ] Consider memory vs. speed tradeoffs\n[ ] Use lazy for large selective queries\n[ ] Pre-build DAG structure","category":"section"},{"location":"tutorials/performance/#Next-Steps","page":"Performance","title":"Next Steps","text":"API Reference - Complete documentation\nExamples - Real-world use cases\nBasic Tutorial - Fundamental concepts","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for OnlineStatsChains.jl.","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#StatDAG","page":"API Reference","title":"StatDAG","text":"","category":"section"},{"location":"api/#CycleError","page":"API Reference","title":"CycleError","text":"Custom exception type raised when attempting to create a cycle in the DAG.\n\nType: CycleError <: Exception\n\nFields:\n\nmsg::String - Error message describing the cycle","category":"section"},{"location":"api/#DAG-Construction","page":"API Reference","title":"DAG Construction","text":"","category":"section"},{"location":"api/#Data-Input","page":"API Reference","title":"Data Input","text":"","category":"section"},{"location":"api/#Value-Retrieval","page":"API Reference","title":"Value Retrieval","text":"","category":"section"},{"location":"api/#value","page":"API Reference","title":"value","text":"","category":"section"},{"location":"api/#values","page":"API Reference","title":"values","text":"","category":"section"},{"location":"api/#Evaluation-Strategies","page":"API Reference","title":"Evaluation Strategies","text":"","category":"section"},{"location":"api/#Edge-Transformations","page":"API Reference","title":"Edge Transformations","text":"","category":"section"},{"location":"api/#Overview","page":"API Reference","title":"Overview","text":"Edge transformations allow you to apply functions to data as it flows through the DAG. This enables data preprocessing, unit conversions, feature extraction, and other transformations without modifying the source nodes.\n\nKey Features:\n\nTransform data on-the-fly as it propagates\nCombine with filters for conditional transformations\nSupports both single-input and multi-input transformations\nBackward compatible: edges without transforms use computed values","category":"section"},{"location":"api/#transform-parameter","page":"API Reference","title":"transform parameter","text":"The transform keyword argument in connect!() accepts a function that will be applied to data propagating through the edge.\n\nSignature: connect!(dag, source, target; transform=nothing, filter=nothing)\n\nParameters:\n\ntransform::Union{Function, Nothing} - Function to apply to propagating data\nfilter::Union{Function, Nothing} - Optional filter to apply before transform\n\nImportant: When a transform or filter is present on an edge, that edge propagates raw data values instead of computed statistics. This enables meaningful transformations of the original data.","category":"section"},{"location":"api/#Basic-Example","page":"API Reference","title":"Basic Example","text":"using OnlineStatsChains, OnlineStats\n\n# Temperature sensor in Celsius, convert to Fahrenheit\ndag = StatDAG()\nadd_node!(dag, :celsius, Mean())\nadd_node!(dag, :fahrenheit, Mean())\n\n# Convert celsius to fahrenheit\nconnect!(dag, :celsius, :fahrenheit, transform = c -> c * 9/5 + 32)\n\n# Input temperature readings in Celsius\nfit!(dag, :celsius => [0.0, 10.0, 20.0, 30.0])\n\nvalue(dag, :celsius)      # 15.0 (mean in Celsius)\nvalue(dag, :fahrenheit)   # 59.0 (mean in Fahrenheit)","category":"section"},{"location":"api/#Data-Extraction-Example","page":"API Reference","title":"Data Extraction Example","text":"Extract specific fields from structured data:\n\ndag = StatDAG()\nadd_node!(dag, :measurements, Mean())\nadd_node!(dag, :prices, Mean())\n\n# Extract price field from measurement objects\nconnect!(dag, :measurements, :prices, transform = m -> m.price)\n\n# Simulate measurements with price and quantity\nmeasurements = [(price=10.0, qty=2), (price=15.0, qty=3), (price=12.0, qty=1)]\nfit!(dag, :measurements => measurements)","category":"section"},{"location":"api/#Combining-Filter-and-Transform","page":"API Reference","title":"Combining Filter and Transform","text":"Filters and transforms work together: filter is applied first, then transform.\n\ndag = StatDAG()\nadd_node!(dag, :temperature, Mean())\nadd_node!(dag, :fahrenheit_high, Mean())\n\n# Only propagate temperatures above 20°C, convert to Fahrenheit\nconnect!(dag, :temperature, :fahrenheit_high,\n         filter = t -> t > 20,\n         transform = t -> t * 9/5 + 32)\n\nfit!(dag, :temperature => [15.0, 25.0, 18.0, 30.0])\n# fahrenheit_high receives only [77.0, 86.0] (from 25°C and 30°C)","category":"section"},{"location":"api/#Multi-Input-Transformations","page":"API Reference","title":"Multi-Input Transformations","text":"Transform functions can process data from multiple parents:\n\ndag = StatDAG()\nadd_node!(dag, :price, Mean())\nadd_node!(dag, :quantity, Mean())\nadd_node!(dag, :revenue, Mean())\n\n# Connect multiple sources with transformation\nconnect!(dag, [:price, :quantity], :revenue,\n         transform = inputs -> inputs[1] * inputs[2])\n\nfit!(dag, Dict(:price => 10.0, :quantity => 5.0))\nvalue(dag, :revenue)  # 50.0","category":"section"},{"location":"api/#Introspection-Functions","page":"API Reference","title":"Introspection Functions","text":"Query edge transformations:\n\n# Check if an edge has a transform\nhas_transform(dag::StatDAG, source::Symbol, target::Symbol) -> Bool\n\n# Get the transform function (or nothing)\nget_transform(dag::StatDAG, source::Symbol, target::Symbol) -> Union{Function, Nothing}\n\nExample:\n\ndag = StatDAG()\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b, transform = x -> x * 2)\n\nhas_transform(dag, :a, :b)  # true\nget_transform(dag, :a, :b)  # returns the transform function","category":"section"},{"location":"api/#Execution-Order","page":"API Reference","title":"Execution Order","text":"When both filter and transform are present on an edge:\n\nFilter is evaluated first with the raw data value\nIf filter returns true, transform is applied\nTransformed value is fitted to the target node","category":"section"},{"location":"api/#Hybrid-Propagation-Model","page":"API Reference","title":"Hybrid Propagation Model","text":"OnlineStatsChains uses a hybrid propagation model for backward compatibility:\n\nEdges WITHOUT filter/transform: Propagate computed values (statistics like means, variances)\nEdges WITH filter OR transform: Propagate raw data values (original input data)\n\nThis ensures existing code continues to work while enabling powerful transformations.","category":"section"},{"location":"api/#Graph-Introspection","page":"API Reference","title":"Graph Introspection","text":"","category":"section"},{"location":"api/#Filter-Introspection","page":"API Reference","title":"Filter Introspection","text":"","category":"section"},{"location":"api/#Transform-Introspection","page":"API Reference","title":"Transform Introspection","text":"","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"These functions are primarily used internally but are documented for advanced usage and package development.","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#OnlineStatsChains.StatDAG","page":"API Reference","title":"OnlineStatsChains.StatDAG","text":"StatDAG(; strategy=:eager)\n\nCreate a new Directed Acyclic Graph (DAG) for chaining OnlineStat computations.\n\nFields\n\nnodes: Dictionary mapping node IDs to Node instances\nedges: Dictionary mapping (from, to) tuples to Edge instances\ntopological_order: Cached topological ordering of nodes\norder_valid: Flag indicating if topological order is current\nstrategy: Evaluation strategy (:eager, :lazy, or :partial)\ndirty_nodes: Set of nodes that need recomputation (lazy mode)\n\nEvaluation Strategies\n\n:eager (default): Propagation happens immediately when fit!() is called\n:lazy: Updates are recorded but not propagated until value() is requested\n:partial: Only affected subgraph is recomputed\n\nExample\n\n# Eager evaluation (default)\ndag = StatDAG()\n\n# Lazy evaluation\ndag = StatDAG(strategy=:lazy)\n\n# Partial evaluation\ndag = StatDAG(strategy=:partial)\n\n\n\n\n\n","category":"type"},{"location":"api/#OnlineStatsChains.add_node!","page":"API Reference","title":"OnlineStatsChains.add_node!","text":"add_node!(dag::StatDAG, id::Symbol, stat::OnlineStat)\n\nAdd a node to the DAG with the given identifier and OnlineStat instance.\n\nThrows ArgumentError if a node with the same id already exists.\n\nArguments\n\ndag: The StatDAG instance\nid: Unique symbol identifier for the node\nstat: An OnlineStat instance to associate with this node\n\nExample\n\ndag = StatDAG()\nadd_node!(dag, :mean, Mean())\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.connect!","page":"API Reference","title":"OnlineStatsChains.connect!","text":"connect!(dag::StatDAG, from_id::Symbol, to_id::Symbol; filter::Union{Function,Nothing}=nothing, transform::Union{Function,Nothing}=nothing)\n\nCreate a directed edge from from_id node to to_id node.\n\nThrows ArgumentError if either node doesn't exist. Throws CycleError if the connection would create a cycle.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\nfilter: Optional filter function to conditionally propagate values\ntransform: Optional transform function to modify values before propagation\n\nWhen both filter and transform are provided, the filter is evaluated first. The transform is only applied if the filter returns true.\n\nExample\n\nconnect!(dag, :source, :sink)\nconnect!(dag, :ema1, :ema2, filter = !ismissing)\nconnect!(dag, :price, :alert, filter = x -> x > 100)\nconnect!(dag, :raw, :scaled, transform = x -> x * 100)\nconnect!(dag, :temp_c, :temp_f, filter = !ismissing, transform = c -> c * 9/5 + 32)\n\n\n\n\n\nconnect!(dag::StatDAG, from_ids::Vector{Symbol}, to_id::Symbol; filter::Union{Function,Nothing}=nothing, transform::Union{Function,Nothing}=nothing)\n\nConnect multiple source nodes to a single destination node (fan-in).\n\nArguments\n\ndag: The StatDAG instance\nfrom_ids: Vector of source node identifiers\nto_id: Destination node identifier\nfilter: Optional filter function applied to combined parent values\ntransform: Optional transform function applied to combined parent values\n\nExample\n\nconnect!(dag, [:input1, :input2], :combined)\nconnect!(dag, [:high, :low], :spread, filter = vals -> all(!ismissing, vals))\nconnect!(dag, [:price, :qty], :total, transform = vals -> vals[1] * vals[2])\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.fit!","page":"API Reference","title":"StatsAPI.fit!","text":"fit!(dag::StatDAG, data::Pair{Symbol, <:Any})\n\nUpdate a source node with data and propagate through the DAG.\n\nArguments\n\ndag: The StatDAG instance\ndata: A Pair of node_id => value or node_id => iterable\n\nIf value is iterable, each element is processed sequentially with propagation.\n\nExample\n\n# Single value\nfit!(dag, :source => 42)\n\n# Batch mode\nfit!(dag, :source => [1, 2, 3, 4, 5])\n\n\n\n\n\nfit!(dag::StatDAG, data::Dict{Symbol, <:Any})\n\nUpdate multiple source nodes simultaneously.\n\nIf values in the Dict are iterables of different lengths, processes up to the shortest length and issues a warning.\n\nExample\n\nfit!(dag, Dict(:input1 => [1, 2, 3], :input2 => [4, 5, 6]))\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsBase.value-Tuple{StatDAG, Symbol}","page":"API Reference","title":"OnlineStatsBase.value","text":"value(dag::StatDAG, id::Symbol)\n\nGet the current value of a node's OnlineStat.\n\nIn lazy mode, this triggers recomputation of dirty nodes if necessary.\n\nThrows KeyError if the node doesn't exist.\n\nExample\n\nval = value(dag, :mean)\n\n\n\n\n\n","category":"method"},{"location":"api/#OnlineStatsChains.values","page":"API Reference","title":"OnlineStatsChains.values","text":"values(dag::StatDAG)\n\nGet a dictionary of all node values.\n\nExample\n\nall_vals = values(dag)\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.set_strategy!","page":"API Reference","title":"OnlineStatsChains.set_strategy!","text":"set_strategy!(dag::StatDAG, strategy::Symbol)\n\nChange the evaluation strategy of an existing DAG.\n\nArguments\n\ndag: The StatDAG instance\nstrategy: New strategy (:eager, :lazy, or :partial)\n\nExample\n\ndag = StatDAG()  # Default eager\nset_strategy!(dag, :lazy)  # Switch to lazy\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.invalidate!","page":"API Reference","title":"OnlineStatsChains.invalidate!","text":"invalidate!(dag::StatDAG, id::Symbol)\n\nMark a node and all its descendants as needing recomputation (lazy mode).\n\nArguments\n\ndag: The StatDAG instance\nid: Node identifier to invalidate\n\nExample\n\ndag = StatDAG(strategy=:lazy)\nadd_node!(dag, :source, Mean())\nfit!(dag, :source => 1.0)\ninvalidate!(dag, :source)  # Mark for recomputation\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.recompute!","page":"API Reference","title":"OnlineStatsChains.recompute!","text":"recompute!(dag::StatDAG)\n\nForce recomputation of all dirty nodes (lazy mode).\n\nExample\n\ndag = StatDAG(strategy=:lazy)\n# ... add nodes and fit data ...\nrecompute!(dag)  # Recompute all dirty nodes\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_nodes","page":"API Reference","title":"OnlineStatsChains.get_nodes","text":"get_nodes(dag::StatDAG)\n\nGet a list of all node IDs in the DAG.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_parents","page":"API Reference","title":"OnlineStatsChains.get_parents","text":"get_parents(dag::StatDAG, id::Symbol)\n\nGet the list of parent node IDs for a given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_children","page":"API Reference","title":"OnlineStatsChains.get_children","text":"get_children(dag::StatDAG, id::Symbol)\n\nGet the list of child node IDs for a given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_topological_order","page":"API Reference","title":"OnlineStatsChains.get_topological_order","text":"get_topological_order(dag::StatDAG)\n\nGet the topological ordering of nodes in the DAG.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.validate","page":"API Reference","title":"OnlineStatsChains.validate","text":"validate(dag::StatDAG)\n\nValidate the DAG structure for consistency. Returns true if valid, throws an error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.has_filter","page":"API Reference","title":"OnlineStatsChains.has_filter","text":"has_filter(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nCheck if an edge has a filter function.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nBool: true if the edge has a filter, false otherwise\n\nExample\n\nif has_filter(dag, :ema1, :ema2)\n    println(\"Edge has a filter\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_filter","page":"API Reference","title":"OnlineStatsChains.get_filter","text":"get_filter(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nGet the filter function for an edge, or nothing if no filter exists.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nUnion{Function, Nothing}: The filter function or nothing\n\nExample\n\nfilter_fn = get_filter(dag, :ema1, :ema2)\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.has_transform","page":"API Reference","title":"OnlineStatsChains.has_transform","text":"has_transform(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nCheck if an edge has a transform function.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nBool: true if the edge has a transform, false otherwise\n\nExample\n\nif has_transform(dag, :raw, :scaled)\n    println(\"Edge has a transform\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_transform","page":"API Reference","title":"OnlineStatsChains.get_transform","text":"get_transform(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nGet the transform function for an edge, or nothing if no transform exists.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nUnion{Function, Nothing}: The transform function or nothing\n\nExample\n\ntransform_fn = get_transform(dag, :raw, :scaled)\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.propagate_value!","page":"API Reference","title":"OnlineStatsChains.propagate_value!","text":"propagate_value!(dag::StatDAG, node_id::Symbol, raw_val)\n\nPropagate from a node to its immediate children.\n\nHybrid propagation model (backward compatible):\n\nIF edge has NO transform: propagates the computed value (cached_value) - ORIGINAL BEHAVIOR\nIF edge has transform: propagates the raw data through the transform - NEW BEHAVIOR\n\nThis preserves backward compatibility while enabling transformers.\n\nArguments\n\ndag: The StatDAG instance\nnode_id: The source node ID\nraw_val: The RAW input value that was just fit!() into the source node\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.has_cycle","page":"API Reference","title":"OnlineStatsChains.has_cycle","text":"has_cycle(dag::StatDAG)\n\nCheck if the DAG contains any cycles using depth-first search. Returns true if a cycle is detected, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.compute_topological_order!","page":"API Reference","title":"OnlineStatsChains.compute_topological_order!","text":"compute_topological_order!(dag::StatDAG)\n\nCompute and cache the topological ordering of nodes in the DAG. Uses Kahn's algorithm (O(V + E) complexity).\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.is_ancestor","page":"API Reference","title":"OnlineStatsChains.is_ancestor","text":"is_ancestor(dag::StatDAG, potential_ancestor::Symbol, node_id::Symbol)\n\nCheck if potentialancestor is an ancestor of nodeid.\n\n\n\n\n\n","category":"function"},{"location":"rocket_integration/#Rocket.jl-Integration","page":"Reactive Programming","title":"Rocket.jl Integration","text":"OnlineStatsChains.jl provides optional integration with Rocket.jl for reactive programming capabilities. This allows you to seamlessly combine statistical DAG computations with reactive data streams.\n\nnote: Optional Dependency\nRocket.jl is an optional dependency. The integration is implemented using Julia's package extension system and only loads when you explicitly install and import Rocket.jl. Core OnlineStatsChains functionality works independently without Rocket.jl.","category":"section"},{"location":"rocket_integration/#Installation","page":"Reactive Programming","title":"Installation","text":"To use the Rocket.jl integration, you need to install both packages:\n\nusing Pkg\nPkg.add(\"OnlineStatsChains\")\nPkg.add(\"Rocket\")\n\nThen load both packages:\n\nusing OnlineStatsChains\nusing OnlineStats\nusing Rocket  # This activates the extension","category":"section"},{"location":"rocket_integration/#Overview","page":"Reactive Programming","title":"Overview","text":"The integration provides three main patterns:\n\nObservable → DAG (Actor pattern): Feed reactive streams into DAG nodes\nDAG → Observable (Emission pattern): Expose DAG results as reactive streams\nBidirectional: Create complete reactive pipelines through the DAG","category":"section"},{"location":"rocket_integration/#Pattern-1:-Observable-DAG-(Actor-Pattern)","page":"Reactive Programming","title":"Pattern 1: Observable → DAG (Actor Pattern)","text":"Use StatDAGActor to feed data from Rocket.jl Observables into DAG nodes.","category":"section"},{"location":"rocket_integration/#Basic-Example","page":"Reactive Programming","title":"Basic Example","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\n# Create DAG\ndag = StatDAG()\nadd_node!(dag, :prices, Mean())\nadd_node!(dag, :variance, Variance())\nconnect!(dag, :prices, :variance)\n\n# Create observable source\nprice_stream = from([100, 102, 101, 103, 105, 104, 106])\n\n# Create actor that feeds into DAG\nactor = StatDAGActor(dag, :prices)\n\n# Subscribe: prices flow through DAG automatically\nsubscription = subscribe!(price_stream, actor)\n\n# Check results\nprintln(\"Mean price: \", value(dag, :prices))\nprintln(\"Variance: \", value(dag, :variance))","category":"section"},{"location":"rocket_integration/#With-Filter","page":"Reactive Programming","title":"With Filter","text":"Filter incoming data before fitting into the DAG:\n\ndag = StatDAG()\nadd_node!(dag, :values, Mean())\n\n# Observable with some missing values\ndata = from([1.0, 2.0, missing, 3.0, missing, 4.0])\n\n# Actor with filter to exclude missing values\nactor = StatDAGActor(dag, :values, filter = !ismissing)\nsubscribe!(data, actor)\n\nprintln(value(dag, :values))  # 2.5 (only non-missing values)","category":"section"},{"location":"rocket_integration/#With-Transform","page":"Reactive Programming","title":"With Transform","text":"Transform incoming data before fitting:\n\ndag = StatDAG()\nadd_node!(dag, :fahrenheit, Mean())\n\n# Temperatures in Celsius\ntemps_c = from([0.0, 10.0, 20.0, 30.0])\n\n# Actor with transform: Celsius to Fahrenheit\nactor = StatDAGActor(dag, :fahrenheit,\n                     transform = c -> c * 9/5 + 32)\nsubscribe!(temps_c, actor)\n\nprintln(value(dag, :fahrenheit))  # 59.0","category":"section"},{"location":"rocket_integration/#Combined-Filter-and-Transform","page":"Reactive Programming","title":"Combined Filter and Transform","text":"dag = StatDAG()\nadd_node!(dag, :temp_f, Mean())\n\n# Mixed data\ntemps_c = from([missing, 10.0, -300.0, 20.0, 30.0])\n\n# Filter out missing and invalid, then convert\nactor = StatDAGActor(dag, :temp_f,\n                     filter = t -> !ismissing(t) && t >= -273.15,\n                     transform = c -> c * 9/5 + 32)\nsubscribe!(temps_c, actor)\n\nprintln(value(dag, :temp_f))  # 68.0","category":"section"},{"location":"rocket_integration/#Pattern-2:-DAG-Observable-(Emission-Pattern)","page":"Reactive Programming","title":"Pattern 2: DAG → Observable (Emission Pattern)","text":"Use to_observable() to convert DAG nodes into Rocket.jl Observables.","category":"section"},{"location":"rocket_integration/#Basic-Example-2","page":"Reactive Programming","title":"Basic Example","text":"dag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :variance, Variance())\nconnect!(dag, :source, :variance)\n\n# Create observable from variance node\nvariance_obs = to_observable(dag, :variance)\n\n# Subscribe to get notified on updates\nsubscribe!(variance_obs, lambda(\n    on_next = x -> println(\"Variance updated: \", x)\n))\n\n# Feed data - observers will be notified\nfit!(dag, :source => randn(100))","category":"section"},{"location":"rocket_integration/#Emit-Types","page":"Reactive Programming","title":"Emit Types","text":"Control what the Observable emits:\n\n# Emit computed values only (default)\nobs_computed = to_observable(dag, :variance)\n\n# Emit raw input values\nobs_raw = to_observable(dag, :variance, emit = :raw)\n\n# Emit both as tuple (raw, computed)\nobs_both = to_observable(dag, :variance, emit = :both)","category":"section"},{"location":"rocket_integration/#Multiple-Observables","page":"Reactive Programming","title":"Multiple Observables","text":"Create Observables from multiple nodes at once:\n\ndag = StatDAG()\nadd_node!(dag, :mean, Mean())\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :sum, Sum())\n\n# Create observables for all nodes\nobservables = to_observables(dag, [:mean, :variance, :sum])\n\n# Subscribe to each\nfor (node_id, obs) in observables\n    subscribe!(obs, lambda(on_next = x -> println(\"$node_id: $x\")))\nend","category":"section"},{"location":"rocket_integration/#Pattern-3:-Bidirectional-Pipeline","page":"Reactive Programming","title":"Pattern 3: Bidirectional Pipeline","text":"Use observable_through_dag() to create complete reactive pipelines.","category":"section"},{"location":"rocket_integration/#Basic-Example-3","page":"Reactive Programming","title":"Basic Example","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\ndag = StatDAG()\nadd_node!(dag, :raw, Mean())\nadd_node!(dag, :smoothed, Variance())\nconnect!(dag, :raw, :smoothed)\n\n# Input: noisy data stream\nnoisy_stream = from(randn(100))\n\n# Output: variance as observable\nvariance_obs = observable_through_dag(noisy_stream, dag, :raw, :smoothed)\n\n# Process reactive pipeline\nsubscribe!(variance_obs, logger())","category":"section"},{"location":"rocket_integration/#Real-World-Examples","page":"Reactive Programming","title":"Real-World Examples","text":"","category":"section"},{"location":"rocket_integration/#Example-1:-Real-time-Sensor-Processing","page":"Reactive Programming","title":"Example 1: Real-time Sensor Processing","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\n# Create DAG for multi-sensor processing\ndag = StatDAG()\nadd_node!(dag, :temp_sensor, Mean())\nadd_node!(dag, :pressure_sensor, Mean())\nadd_node!(dag, :humidity_sensor, Mean())\nadd_node!(dag, :alert_system, Mean())\n\nconnect!(dag, :temp_sensor, :alert_system, filter = t -> t > 80)\nconnect!(dag, :pressure_sensor, :alert_system, filter = p -> p < 900)\n\n# Create observable streams from sensors\ntemp_stream = interval(1000) |> map(Float64, _ -> 20 + 10 * randn())\npressure_stream = interval(1000) |> map(Float64, _ -> 1013 + 5 * randn())\nhumidity_stream = interval(1000) |> map(Float64, _ -> 50 + 10 * randn())\n\n# Connect streams to DAG\nsubscribe!(temp_stream, StatDAGActor(dag, :temp_sensor))\nsubscribe!(pressure_stream, StatDAGActor(dag, :pressure_sensor))\nsubscribe!(humidity_stream, StatDAGActor(dag, :humidity_sensor))\n\n# Monitor alerts\nalert_obs = to_observable(dag, :alert_system)\nsubscribe!(alert_obs, lambda(\n    on_next = x -> @warn \"Alert triggered! Value: $x\"\n))","category":"section"},{"location":"rocket_integration/#Example-2:-Financial-Market-Data-Stream","page":"Reactive Programming","title":"Example 2: Financial Market Data Stream","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\n# DAG for technical indicators\ndag = StatDAG()\nadd_node!(dag, :price, Mean())\nadd_node!(dag, :sma_20, Mean())  # Simple moving average\nadd_node!(dag, :variance, Variance())  # Price variance\nadd_node!(dag, :extrema, Extrema())  # Min/max tracking\n\nconnect!(dag, :price, :sma_20)\nconnect!(dag, :price, :variance)\nconnect!(dag, :price, :extrema)\n\n# Market data stream (simulated)\nmarket_stream = interval(100) |> map(Float64, _ -> 100 + randn())\n\n# Feed into DAG and expose variance as observable\nsubscribe!(market_stream, StatDAGActor(dag, :price))\nvariance_signal = to_observable(dag, :variance)\n\n# Trading signal logic\nsubscribe!(variance_signal, lambda(\n    on_next = x -> begin\n        if x > 10\n            println(\"High volatility: Variance = $x\")\n        elseif x < 2\n            println(\"Low volatility: Variance = $x\")\n        end\n    end\n))","category":"section"},{"location":"rocket_integration/#API-Reference","page":"Reactive Programming","title":"API Reference","text":"","category":"section"},{"location":"rocket_integration/#StatDAGActor","page":"Reactive Programming","title":"StatDAGActor","text":"StatDAGActor(dag::StatDAG, node_id::Symbol;\n             filter=nothing, transform=nothing)\n\nActor that feeds incoming data from a Rocket.jl Observable into a StatDAG node.\n\nArguments:\n\ndag::StatDAG: The DAG instance\nnode_id::Symbol: The target node identifier\nfilter::Union{Function, Nothing}: Optional filter function\ntransform::Union{Function, Nothing}: Optional transform function\n\nMethods:\n\non_next!(actor, data): Handle incoming data\non_error!(actor, error): Handle errors\non_complete!(actor): Handle stream completion","category":"section"},{"location":"rocket_integration/#to_observable","page":"Reactive Programming","title":"to_observable","text":"to_observable(dag::StatDAG, node_id::Symbol; emit=:computed)\n\nConvert a StatDAG node into a Rocket.jl Observable.\n\nArguments:\n\ndag::StatDAG: The DAG instance\nnode_id::Symbol: The node to observe\nemit::Symbol: What to emit - :computed, :raw, or :both\n\nReturns:\n\nStatDAGObservable: An observable that emits node values","category":"section"},{"location":"rocket_integration/#to_observables","page":"Reactive Programming","title":"to_observables","text":"to_observables(dag::StatDAG, node_ids::Vector{Symbol}; emit=:computed)\n\nCreate multiple observables from DAG nodes.\n\nArguments:\n\ndag::StatDAG: The DAG instance\nnode_ids::Vector{Symbol}: Vector of node IDs to observe\nemit::Symbol: What to emit - :computed, :raw, or :both\n\nReturns:\n\nDict{Symbol, StatDAGObservable}: Dictionary mapping node IDs to observables","category":"section"},{"location":"rocket_integration/#observable*through*dag","page":"Reactive Programming","title":"observablethroughdag","text":"observable_through_dag(observable, dag::StatDAG,\n                       source_node::Symbol, sink_node::Symbol)\n\nCreate a reactive pipeline: Observable → DAG → Observable\n\nArguments:\n\nobservable: Input Rocket.jl Observable\ndag::StatDAG: The DAG to process data through\nsource_node::Symbol: DAG node to receive input data\nsink_node::Symbol: DAG node to emit output from\n\nReturns:\n\nStatDAGObservable: Observable emitting processed results","category":"section"},{"location":"rocket_integration/#When-to-Use","page":"Reactive Programming","title":"When to Use","text":"","category":"section"},{"location":"rocket_integration/#Use-Pure-StatDAG-When:","page":"Reactive Programming","title":"Use Pure StatDAG When:","text":"Processing complete datasets (batch mode)\nSynchronous, deterministic workflows\nSimple linear or tree pipelines\nAll data is available upfront","category":"section"},{"location":"rocket_integration/#Use-StatDAG-Rocket.jl-When:","page":"Reactive Programming","title":"Use StatDAG + Rocket.jl When:","text":"Processing real-time event streams\nHandling asynchronous data sources\nBuilding reactive, event-driven systems\nDealing with multiple concurrent streams\nNeed time-based operations (windowing, throttling)","category":"section"},{"location":"rocket_integration/#Performance-Considerations","page":"Reactive Programming","title":"Performance Considerations","text":"Aspect Pure StatDAG StatDAG + Rocket.jl\nLatency Lowest (direct calls) Higher (event dispatch)\nThroughput Highest (batch mode) Good (streaming mode)\nMemory Lower Higher (buffering)\nCPU Lower overhead Additional dispatch cost\nScalability Limited by memory Better for streams\n\nRecommendation: Use Rocket.jl integration when you need reactive/async capabilities; stick with pure StatDAG for simpler batch processing.","category":"section"},{"location":"rocket_integration/#Troubleshooting","page":"Reactive Programming","title":"Troubleshooting","text":"","category":"section"},{"location":"rocket_integration/#Extension-Not-Loading","page":"Reactive Programming","title":"Extension Not Loading","text":"If the Rocket.jl integration doesn't work:\n\nEnsure you're using Julia 1.10 or later\nCheck that Rocket.jl is installed: using Pkg; Pkg.status(\"Rocket\")\nLoad Rocket.jl before using integration functions: using Rocket\nCheck for errors: Base.get_extension(OnlineStatsChains, :OnlineStatsChainsRocketExt)","category":"section"},{"location":"rocket_integration/#Common-Errors","page":"Reactive Programming","title":"Common Errors","text":"KeyError: Node doesn't exist\n\n# Make sure to add nodes before creating actors/observables\nadd_node!(dag, :mynode, Mean())\nactor = StatDAGActor(dag, :mynode)  # OK\n\nArgumentError: Invalid emit type\n\n# Use only :computed, :raw, or :both\nobs = to_observable(dag, :node, emit=:computed)  # OK\nobs = to_observable(dag, :node, emit=:invalid)   # Error","category":"section"},{"location":"rocket_integration/#See-Also","page":"Reactive Programming","title":"See Also","text":"Rocket.jl Documentation\nOnlineStatsChains.jl Basic Usage\nAPI Reference\nExamples","category":"section"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"This guide will get you up and running with OnlineStatsChains.jl in minutes.","category":"section"},{"location":"quickstart/#Basic-Workflow","page":"Quick Start","title":"Basic Workflow","text":"The typical workflow consists of four steps:\n\nCreate a DAG\nAdd nodes\nConnect nodes\nFit data","category":"section"},{"location":"quickstart/#Your-First-DAG","page":"Quick Start","title":"Your First DAG","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Step 1: Create a DAG\ndag = StatDAG()\n\n# Step 2: Add nodes with OnlineStats\nadd_node!(dag, :data, Mean())\nadd_node!(dag, :variance, Variance())\n\n# Step 3: Connect nodes\nconnect!(dag, :data, :variance)\n\n# Step 4: Fit data\nfor x in randn(100)\n    fit!(dag, :data => x)\nend\n\n# Get results\nprintln(\"Mean: \", value(dag, :data))\nprintln(\"Variance: \", value(dag, :variance))","category":"section"},{"location":"quickstart/#Batch-Processing","page":"Quick Start","title":"Batch Processing","text":"Process entire arrays at once:\n\ndag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :downstream, Mean())\nconnect!(dag, :source, :downstream)\n\n# Batch mode\ndata = randn(1000)\nfit!(dag, :source => data)\n\nprintln(\"Result: \", value(dag, :downstream))","category":"section"},{"location":"quickstart/#Evaluation-Strategies","page":"Quick Start","title":"Evaluation Strategies","text":"","category":"section"},{"location":"quickstart/#Eager-Evaluation-(Default)","page":"Quick Start","title":"Eager Evaluation (Default)","text":"Immediate propagation:\n\ndag = StatDAG()  # Eager by default\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)  # Propagates to :b immediately\nvalue(dag, :b)  # Already computed","category":"section"},{"location":"quickstart/#Lazy-Evaluation","page":"Quick Start","title":"Lazy Evaluation","text":"Deferred computation:\n\ndag = StatDAG(strategy=:lazy)\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)  # No propagation\nvalue(dag, :b)  # Triggers computation","category":"section"},{"location":"quickstart/#Common-Patterns","page":"Quick Start","title":"Common Patterns","text":"","category":"section"},{"location":"quickstart/#Linear-Chain","page":"Quick Start","title":"Linear Chain","text":"dag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :middle, Mean())\nadd_node!(dag, :sink, Mean())\n\nconnect!(dag, :source, :middle)\nconnect!(dag, :middle, :sink)\n\nfit!(dag, :source => randn(100))","category":"section"},{"location":"quickstart/#Fan-Out","page":"Quick Start","title":"Fan-Out","text":"One source, multiple destinations:\n\ndag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :branch1, Variance())\nadd_node!(dag, :branch2, Extrema())\n\nconnect!(dag, :source, :branch1)\nconnect!(dag, :source, :branch2)\n\nfit!(dag, :source => randn(100))","category":"section"},{"location":"quickstart/#Fan-In","page":"Quick Start","title":"Fan-In","text":"Multiple sources, one destination:\n\ndag = StatDAG()\nadd_node!(dag, :input1, Mean())\nadd_node!(dag, :input2, Mean())\nadd_node!(dag, :combined, Mean())\n\nconnect!(dag, [:input1, :input2], :combined)\n\nfit!(dag, Dict(\n    :input1 => randn(50),\n    :input2 => randn(50)\n))","category":"section"},{"location":"quickstart/#Edge-Transformations","page":"Quick Start","title":"Edge Transformations","text":"Transform data as it flows through the DAG:","category":"section"},{"location":"quickstart/#Basic-Transform","page":"Quick Start","title":"Basic Transform","text":"dag = StatDAG()\nadd_node!(dag, :celsius, Mean())\nadd_node!(dag, :fahrenheit, Mean())\n\n# Convert Celsius to Fahrenheit\nconnect!(dag, :celsius, :fahrenheit, transform = c -> c * 9/5 + 32)\n\nfit!(dag, :celsius => [0.0, 10.0, 20.0, 30.0])\nvalue(dag, :celsius)      # 15.0°C\nvalue(dag, :fahrenheit)   # 59.0°F","category":"section"},{"location":"quickstart/#Filtered-Transform","page":"Quick Start","title":"Filtered Transform","text":"Combine filters with transformations:\n\ndag = StatDAG()\nadd_node!(dag, :raw, Mean())\nadd_node!(dag, :valid, Mean())\n\n# Only propagate non-missing values\nconnect!(dag, :raw, :valid, filter = !ismissing)\n\nfit!(dag, :raw => [1.0, missing, 2.0, 3.0])\nvalue(dag, :valid)  # 2.0 (only valid values)","category":"section"},{"location":"quickstart/#Data-Extraction","page":"Quick Start","title":"Data Extraction","text":"Extract fields from structured data:\n\ndag = StatDAG()\nadd_node!(dag, :transactions, Mean())\nadd_node!(dag, :prices, Mean())\n\n# Extract price from transaction\nconnect!(dag, :transactions, :prices, transform = t -> t.price)\n\ntransactions = [(price=10.0, qty=5), (price=15.0, qty=3)]\nfit!(dag, :transactions => transactions)\nvalue(dag, :prices)  # 12.5 (mean of prices)","category":"section"},{"location":"quickstart/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"Basic Usage Tutorial - Learn fundamental concepts\nAdvanced Patterns - Complex DAG structures\nAPI Reference - Complete function documentation","category":"section"},{"location":"tutorials/advanced/#Advanced-Patterns","page":"Advanced Patterns","title":"Advanced Patterns","text":"This tutorial covers advanced DAG patterns and techniques.","category":"section"},{"location":"tutorials/advanced/#Fan-Out-Pattern","page":"Advanced Patterns","title":"Fan-Out Pattern","text":"One source feeding multiple downstream nodes.","category":"section"},{"location":"tutorials/advanced/#Basic-Fan-Out","page":"Advanced Patterns","title":"Basic Fan-Out","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\n# One source\nadd_node!(dag, :source, Mean())\n\n# Multiple destinations\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :extrema, Extrema())\nadd_node!(dag, :quantile, Quantile(0.95))\n\n# Connect one-to-many\nconnect!(dag, :source, :variance)\nconnect!(dag, :source, :extrema)\nconnect!(dag, :source, :quantile)\n\n# All downstream nodes receive updates\nfit!(dag, :source => randn(1000))\n\nVisualization:\n\n        ┌→ variance\nsource ─┼→ extrema\n        └→ quantile","category":"section"},{"location":"tutorials/advanced/#Fan-In-Pattern","page":"Advanced Patterns","title":"Fan-In Pattern","text":"Multiple sources feeding one destination.","category":"section"},{"location":"tutorials/advanced/#Basic-Fan-In","page":"Advanced Patterns","title":"Basic Fan-In","text":"dag = StatDAG()\n\n# Multiple sources\nadd_node!(dag, :high, Mean())\nadd_node!(dag, :low, Mean())\n\n# One destination\nadd_node!(dag, :spread, Mean())\n\n# Connect many-to-one\nconnect!(dag, [:high, :low], :spread)\n\n# Synchronized update\nfit!(dag, Dict(\n    :high => [105.0, 107.0, 106.0],\n    :low => [98.0, 99.0, 100.0]\n))\n\nprintln(\"Spread: \", value(dag, :spread))\n\nVisualization:\n\nhigh ─┐\n      ├→ spread\nlow ──┘","category":"section"},{"location":"tutorials/advanced/#Custom-Multi-Input-Stats","page":"Advanced Patterns","title":"Custom Multi-Input Stats","text":"For fan-in, the destination receives an array of parent values:\n\n# Custom stat that expects array input\nstruct SpreadStat <: OnlineStat{Vector{Float64}}\n    mean::Mean\nend\n\nSpreadStat() = SpreadStat(Mean())\n\nfunction OnlineStatsBase._fit!(s::SpreadStat, data::Vector)\n    # data = [high_value, low_value]\n    spread = data[1] - data[2]\n    fit!(s.mean, spread)\nend\n\nOnlineStatsBase.value(s::SpreadStat) = value(s.mean)\n\n# Use in DAG\ndag = StatDAG()\nadd_node!(dag, :high, Mean())\nadd_node!(dag, :low, Mean())\nadd_node!(dag, :spread, SpreadStat())\n\nconnect!(dag, [:high, :low], :spread)","category":"section"},{"location":"tutorials/advanced/#Diamond-Pattern","page":"Advanced Patterns","title":"Diamond Pattern","text":"Source splits and reconverges.\n\ndag = StatDAG()\n\n# Source\nadd_node!(dag, :source, Mean())\n\n# Split\nadd_node!(dag, :path1, Mean())\nadd_node!(dag, :path2, Variance())\n\n# Reconverge\nadd_node!(dag, :sink, Mean())\n\n# Build diamond\nconnect!(dag, :source, :path1)\nconnect!(dag, :source, :path2)\nconnect!(dag, [:path1, :path2], :sink)\n\nfit!(dag, :source => randn(100))\n\nVisualization:\n\n         path1 ─┐\nsource ─┤       ├→ sink\n         path2 ─┘","category":"section"},{"location":"tutorials/advanced/#Layered-DAG","page":"Advanced Patterns","title":"Layered DAG","text":"Multiple processing stages:\n\ndag = StatDAG()\n\n# Input layer\nadd_node!(dag, :raw_data, Mean())\n\n# Processing layer\nadd_node!(dag, :normalized, Mean())\nadd_node!(dag, :smoothed, Mean())\n\n# Analysis layer\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :trend, Mean())\n\n# Connect layers\nconnect!(dag, :raw_data, :normalized)\nconnect!(dag, :normalized, :smoothed)\nconnect!(dag, :smoothed, :variance)\nconnect!(dag, :smoothed, :trend)\n\nVisualization:\n\nraw_data → normalized → smoothed ─┬→ variance\n                                  └→ trend","category":"section"},{"location":"tutorials/advanced/#Mixed-Batch-and-Streaming","page":"Advanced Patterns","title":"Mixed Batch and Streaming","text":"Combine different input modes:\n\ndag = StatDAG()\n\nadd_node!(dag, :stream, Mean())\nadd_node!(dag, :batch, Mean())\nadd_node!(dag, :combined, Mean())\n\nconnect!(dag, :stream, :combined)\nconnect!(dag, :batch, :combined)\n\n# Stream single values\nfor x in randn(10)\n    fit!(dag, :stream => x)\nend\n\n# Batch array\nfit!(dag, :batch => randn(100))","category":"section"},{"location":"tutorials/advanced/#Conditional-Processing","page":"Advanced Patterns","title":"Conditional Processing","text":"Use different strategies for different branches:\n\n# Main DAG with eager evaluation\ndag = StatDAG(strategy=:eager)\n\nadd_node!(dag, :realtime, Mean())\nadd_node!(dag, :analysis, Variance())\n\nconnect!(dag, :realtime, :analysis)\n\n# Realtime updates\nfit!(dag, :realtime => sensor_reading())\n\n# Switch to lazy for batch processing\nset_strategy!(dag, :lazy)\n\n# Batch updates don't propagate\nfit!(dag, :realtime => historical_data)\n\n# Trigger when ready\nvalue(dag, :analysis)","category":"section"},{"location":"tutorials/advanced/#Multi-Level-Aggregation","page":"Advanced Patterns","title":"Multi-Level Aggregation","text":"Hierarchical aggregation:\n\ndag = StatDAG()\n\n# Leaf level - individual sensors\nadd_node!(dag, :sensor1, Mean())\nadd_node!(dag, :sensor2, Mean())\nadd_node!(dag, :sensor3, Mean())\n\n# Mid level - zones\nadd_node!(dag, :zone1, Mean())\nadd_node!(dag, :zone2, Mean())\n\n# Top level - building\nadd_node!(dag, :building, Mean())\n\n# Build hierarchy\nconnect!(dag, [:sensor1, :sensor2], :zone1)\nconnect!(dag, :sensor3, :zone2)\nconnect!(dag, [:zone1, :zone2], :building)\n\n# Update sensors\nfit!(dag, Dict(\n    :sensor1 => [20.0, 21.0],\n    :sensor2 => [19.0, 20.0],\n    :sensor3 => [22.0, 23.0]\n))\n\nVisualization:\n\nsensor1 ─┐\n         ├→ zone1 ─┐\nsensor2 ─┘         │\n                   ├→ building\nsensor3 ─→ zone2 ──┘","category":"section"},{"location":"tutorials/advanced/#Time-Series-Pipeline","page":"Advanced Patterns","title":"Time-Series Pipeline","text":"Process time-series with multiple indicators:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\n# Price input\nadd_node!(dag, :price, Mean())\n\n# Technical indicators\nadd_node!(dag, :sma_short, Mean())  # Short SMA\nadd_node!(dag, :sma_long, Mean())   # Long SMA\nadd_node!(dag, :volatility, Variance())\n\n# Signals\nadd_node!(dag, :momentum, Mean())\n\n# Build pipeline\nconnect!(dag, :price, :sma_short)\nconnect!(dag, :price, :sma_long)\nconnect!(dag, :price, :volatility)\nconnect!(dag, [:sma_short, :sma_long], :momentum)\n\n# Process prices\nprices = [100.0, 102.0, 101.0, 103.0, 105.0, 104.0, 106.0]\nfit!(dag, :price => prices)\n\n# Get indicators\nprintln(\"Short SMA: \", value(dag, :sma_short))\nprintln(\"Long SMA: \", value(dag, :sma_long))\nprintln(\"Volatility: \", value(dag, :volatility))","category":"section"},{"location":"tutorials/advanced/#Dynamic-DAG-Construction","page":"Advanced Patterns","title":"Dynamic DAG Construction","text":"Build DAGs programmatically:\n\nfunction create_sensor_network(n_sensors::Int)\n    dag = StatDAG()\n\n    # Add sensor nodes\n    for i in 1:n_sensors\n        add_node!(dag, Symbol(\"sensor_\", i), Mean())\n    end\n\n    # Add aggregator\n    add_node!(dag, :aggregator, Mean())\n\n    # Connect all sensors to aggregator\n    sensor_ids = [Symbol(\"sensor_\", i) for i in 1:n_sensors]\n    connect!(dag, sensor_ids, :aggregator)\n\n    return dag\nend\n\n# Create network with 5 sensors\ndag = create_sensor_network(5)\n\n# Update all sensors\nsensor_data = Dict(\n    Symbol(\"sensor_\", i) => randn(10)\n    for i in 1:5\n)\nfit!(dag, sensor_data)","category":"section"},{"location":"tutorials/advanced/#Lazy-Evaluation-for-Large-Graphs","page":"Advanced Patterns","title":"Lazy Evaluation for Large Graphs","text":"Optimize large DAGs with lazy evaluation:\n\ndag = StatDAG(strategy=:lazy)\n\n# Build large graph\nfor i in 1:100\n    add_node!(dag, Symbol(\"node_\", i), Mean())\nend\n\n# Create connections\nfor i in 1:99\n    connect!(dag, Symbol(\"node_\", i), Symbol(\"node_\", i+1))\nend\n\n# Fit data (no propagation)\nfit!(dag, :node_1 => randn(1000))\n\n# Only compute what's needed\nvalue(dag, :node_100)  # Triggers computation of entire chain","category":"section"},{"location":"tutorials/advanced/#Manual-Invalidation","page":"Advanced Patterns","title":"Manual Invalidation","text":"Fine-grained control with lazy mode:\n\ndag = StatDAG(strategy=:lazy)\n\nadd_node!(dag, :input, Mean())\nadd_node!(dag, :output, Mean())\nconnect!(dag, :input, :output)\n\n# Initial computation\nfit!(dag, :input => 1.0)\nvalue(dag, :output)  # Computes\n\n# Invalidate manually\ninvalidate!(dag, :input)\n\n# Recompute when needed\nrecompute!(dag)","category":"section"},{"location":"tutorials/advanced/#Next-Steps","page":"Advanced Patterns","title":"Next Steps","text":"Performance Guide - Optimization techniques\nAPI Reference - Complete documentation\nExamples - Real-world use cases","category":"section"},{"location":"ai-generated/#AI-Generated-Package-Important-Notice","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Package - Important Notice","text":"","category":"section"},{"location":"ai-generated/#Generation-Method","page":"⚠️ AI-Generated Notice","title":"Generation Method","text":"OnlineStatsChains.jl v0.1.0 was entirely generated using Claude Code (Claude 3.5 Sonnet), an AI coding assistant from Anthropic.","category":"section"},{"location":"ai-generated/#What-This-Means","page":"⚠️ AI-Generated Notice","title":"What This Means","text":"This package was created through:\n\nAI-driven development from a detailed EARS specification\nAutomated code generation with human oversight\nAI-written tests using BDD methodology\nAI-generated documentation including all tutorials and examples","category":"section"},{"location":"ai-generated/#Important-Considerations","page":"⚠️ AI-Generated Notice","title":"⚠️ Important Considerations","text":"","category":"section"},{"location":"ai-generated/#Potential-Risks","page":"⚠️ AI-Generated Notice","title":"Potential Risks","text":"Users should be aware of the following considerations when using AI-generated code:","category":"section"},{"location":"ai-generated/#1.-**Code-Quality-and-Correctness**","page":"⚠️ AI-Generated Notice","title":"1. Code Quality & Correctness","text":"✅ Mitigated by: 72 BDD tests, all passing\n⚠️ Risk: Edge cases may not be fully covered despite high test coverage\nRecommendation: Review critical paths and add application-specific tests","category":"section"},{"location":"ai-generated/#2.-**Security-Concerns**","page":"⚠️ AI-Generated Notice","title":"2. Security Concerns","text":"✅ Mitigated by: No external dependencies beyond OnlineStatsBase.jl\n⚠️ Risk: AI-generated code may have subtle vulnerabilities\nRecommendation: Security audit before production use in sensitive contexts","category":"section"},{"location":"ai-generated/#3.-**Maintenance-and-Understanding**","page":"⚠️ AI-Generated Notice","title":"3. Maintenance & Understanding","text":"✅ Mitigated by: Comprehensive documentation and clear code structure\n⚠️ Risk: Original developers may not have deep implementation knowledge\nRecommendation: Study the codebase thoroughly before modifications","category":"section"},{"location":"ai-generated/#4.-**Edge-Cases-and-Corner-Cases**","page":"⚠️ AI-Generated Notice","title":"4. Edge Cases & Corner Cases","text":"✅ Mitigated by: BDD tests cover main scenarios\n⚠️ Risk: Unusual usage patterns may trigger unexpected behavior\nRecommendation: Test thoroughly in your specific use case","category":"section"},{"location":"ai-generated/#5.-**Performance-Characteristics**","page":"⚠️ AI-Generated Notice","title":"5. Performance Characteristics","text":"✅ Mitigated by: Algorithms designed for O(V+E) complexity\n⚠️ Risk: Real-world performance may vary with specific data patterns\nRecommendation: Benchmark with your actual workload","category":"section"},{"location":"ai-generated/#6.-**API-Design**","page":"⚠️ AI-Generated Notice","title":"6. API Design","text":"✅ Mitigated by: Based on detailed EARS specification\n⚠️ Risk: API may not follow all Julia community best practices\nRecommendation: Provide feedback if you find API inconsistencies","category":"section"},{"location":"ai-generated/#Verification-Steps-Taken","page":"⚠️ AI-Generated Notice","title":"🔍 Verification Steps Taken","text":"Despite being AI-generated, this package includes:\n\nComprehensive Testing\n72 BDD-style tests (Given-When-Then)\n90% code coverage\nAll tests passing\nSpecification Compliance\n100% conformance to EARS specification\n48/48 high-priority requirements met\n33/33 medium-priority requirements met\nCode Review Checkpoints\nCycle detection algorithm (DFS) verified\nTopological sort (Kahn's algorithm) verified\nError handling reviewed\nPerformance complexity validated\nDocumentation Quality\nComplete API documentation\nThree detailed tutorials\nReal-world examples\nPerformance guide","category":"section"},{"location":"ai-generated/#Recommended-Due-Diligence","page":"⚠️ AI-Generated Notice","title":"✅ Recommended Due Diligence","text":"Before using this package in production, consider:","category":"section"},{"location":"ai-generated/#For-All-Users","page":"⚠️ AI-Generated Notice","title":"For All Users","text":"Read the documentation carefully\nRun the test suite (Pkg.test(\"OnlineStatsChains\"))\nReview the source code (only 729 lines - manageable)\nTest with your specific use case\nReport any issues on GitHub","category":"section"},{"location":"ai-generated/#For-Critical-Applications","page":"⚠️ AI-Generated Notice","title":"For Critical Applications","text":"Security audit of the codebase\nExtended testing beyond included tests\nPerformance benchmarking with real data\nCode review by Julia experts\nConsider forking for internal modifications","category":"section"},{"location":"ai-generated/#For-Contributors","page":"⚠️ AI-Generated Notice","title":"For Contributors","text":"Understand the architecture before contributing\nAdd tests for new features\nUpdate documentation accordingly\nFollow Julia best practices\nReview AI-generated code critically","category":"section"},{"location":"ai-generated/#Transparency-Metrics","page":"⚠️ AI-Generated Notice","title":"📊 Transparency Metrics","text":"Aspect Details\nGenerator Claude Code (Anthropic)\nModel Claude 3.5 Sonnet\nSpecification EARS format, ai and human-written\nHuman Review Continuous oversight during generation\nTest Coverage >90%\nLines of Code 729 (src) + 1,010 (tests)\nDocumentation 2,777 lines (AI-generated)","category":"section"},{"location":"ai-generated/#Community-Feedback","page":"⚠️ AI-Generated Notice","title":"🤝 Community Feedback","text":"This package is an experiment in AI-assisted package development. We welcome:\n\nBug reports - especially for edge cases\nPerformance feedback - real-world usage data\nCode review - suggestions for improvements\nBest practices - Julia community standards\nSecurity concerns - responsible disclosure","category":"section"},{"location":"ai-generated/#Ethical-Considerations","page":"⚠️ AI-Generated Notice","title":"📜 Ethical Considerations","text":"","category":"section"},{"location":"ai-generated/#Transparency","page":"⚠️ AI-Generated Notice","title":"Transparency","text":"We believe in full transparency about AI-generated code. This notice ensures users can make informed decisions.","category":"section"},{"location":"ai-generated/#Responsibility","page":"⚠️ AI-Generated Notice","title":"Responsibility","text":"While AI-generated, the package maintainer takes full responsibility for:\n\nCode quality and correctness\nSecurity vulnerabilities\nUser support and maintenance\nBug fixes and improvements","category":"section"},{"location":"ai-generated/#Attribution","page":"⚠️ AI-Generated Notice","title":"Attribution","text":"Code Generation: Claude Code (Anthropic)\nSpecification: Human-written EARS format\nTesting Methodology: BDD (Behavior-Driven Development)\nOversight: Continuous human review","category":"section"},{"location":"ai-generated/#Future-Development","page":"⚠️ AI-Generated Notice","title":"🔮 Future Development","text":"As AI coding tools evolve, this package may serve as a case study for:\n\nAI-generated package quality assessment\nBest practices for AI-assisted development\nTesting strategies for generated code\nDocumentation standards for AI tools","category":"section"},{"location":"ai-generated/#Legal-Notice","page":"⚠️ AI-Generated Notice","title":"⚖️ Legal Notice","text":"This package is provided \"as is\" without warranty of any kind. Users assume all risks associated with using AI-generated code. See LICENSE for full terms.","category":"section"},{"location":"ai-generated/#Contact","page":"⚠️ AI-Generated Notice","title":"📞 Contact","text":"For questions, concerns, or feedback about the AI-generation process:\n\nGitHub Issues: Report problems\nDiscussions: Ask questions\nSecurity: Responsible disclosure via private channels\n\n\n\nRemember: AI-generated code is a tool, not a replacement for human judgment. Always review, test, and validate before deploying to production.\n\nLast updated: 2025-10-03","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Real-world examples demonstrating OnlineStatsChains.jl.","category":"section"},{"location":"examples/#Financial-Time-Series-Analysis","page":"Examples","title":"Financial Time Series Analysis","text":"Track multiple technical indicators:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_trading_dag()\n    dag = StatDAG()\n\n    # Price input\n    add_node!(dag, :price, Mean())\n\n    # Technical indicators\n    add_node!(dag, :sma_5, Mean())\n    add_node!(dag, :sma_20, Mean())\n    add_node!(dag, :volatility, Variance())\n    add_node!(dag, :range, Extrema())\n\n    # Build pipeline\n    connect!(dag, :price, :sma_5)\n    connect!(dag, :price, :sma_20)\n    connect!(dag, :price, :volatility)\n    connect!(dag, :price, :range)\n\n    return dag\nend\n\n# Use the DAG\ndag = create_trading_dag()\n\n# Stream price data\nprices = [100.0, 102.0, 101.0, 103.0, 105.0, 104.0, 106.0, 108.0]\nfit!(dag, :price => prices)\n\n# Get indicators\nprintln(\"Price: \", value(dag, :price))\nprintln(\"SMA(5): \", value(dag, :sma_5))\nprintln(\"SMA(20): \", value(dag, :sma_20))\nprintln(\"Volatility: \", value(dag, :volatility))\nprintln(\"Range: \", value(dag, :range))","category":"section"},{"location":"examples/#Sensor-Network-Monitoring","page":"Examples","title":"Sensor Network Monitoring","text":"Multi-sensor aggregation:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_sensor_network()\n    dag = StatDAG()\n\n    # Individual sensors\n    add_node!(dag, :temp_1, Mean())\n    add_node!(dag, :temp_2, Mean())\n    add_node!(dag, :temp_3, Mean())\n\n    # Zone aggregates\n    add_node!(dag, :zone_avg, Mean())\n    add_node!(dag, :zone_var, Variance())\n\n    # Building-level stats\n    add_node!(dag, :building, Mean())\n\n    # Connect sensors to zones\n    connect!(dag, [:temp_1, :temp_2, :temp_3], :zone_avg)\n    connect!(dag, [:temp_1, :temp_2, :temp_3], :zone_var)\n\n    # Connect to building\n    connect!(dag, :zone_avg, :building)\n\n    return dag\nend\n\n# Monitor sensors\ndag = create_sensor_network()\n\n# Update sensors (different sample sizes)\nfit!(dag, Dict(\n    :temp_1 => [20.1, 20.3, 20.2],\n    :temp_2 => [19.8, 20.0, 19.9],\n    :temp_3 => [20.5, 20.7]\n))\n\nprintln(\"Zone average: \", value(dag, :zone_avg))\nprintln(\"Zone variance: \", value(dag, :zone_var))\nprintln(\"Building temp: \", value(dag, :building))","category":"section"},{"location":"examples/#Streaming-Data-Pipeline","page":"Examples","title":"Streaming Data Pipeline","text":"Process real-time data with lazy evaluation:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_streaming_pipeline()\n    # Use lazy for efficiency\n    dag = StatDAG(strategy=:lazy)\n\n    # Raw data input\n    add_node!(dag, :raw, Mean())\n\n    # Processing stages\n    add_node!(dag, :filtered, Mean())\n    add_node!(dag, :normalized, Mean())\n\n    # Analytics\n    add_node!(dag, :stats, Variance())\n    add_node!(dag, :summary, Extrema())\n\n    # Build pipeline\n    connect!(dag, :raw, :filtered)\n    connect!(dag, :filtered, :normalized)\n    connect!(dag, :normalized, :stats)\n    connect!(dag, :normalized, :summary)\n\n    return dag\nend\n\n# Process stream\ndag = create_streaming_pipeline()\n\n# Accumulate data (no propagation in lazy mode)\nfor batch in data_stream\n    fit!(dag, :raw => batch)\nend\n\n# Trigger computation when needed\nstats_value = value(dag, :stats)\nsummary_value = value(dag, :summary)","category":"section"},{"location":"examples/#Quality-Control-System","page":"Examples","title":"Quality Control System","text":"Multi-stage quality checks:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_qc_pipeline()\n    dag = StatDAG()\n\n    # Measurement inputs\n    add_node!(dag, :measurement, Mean())\n\n    # Quality metrics\n    add_node!(dag, :mean_check, Mean())\n    add_node!(dag, :variance_check, Variance())\n    add_node!(dag, :range_check, Extrema())\n\n    # Aggregate QC\n    add_node!(dag, :qc_status, Mean())\n\n    # Build pipeline\n    connect!(dag, :measurement, :mean_check)\n    connect!(dag, :measurement, :variance_check)\n    connect!(dag, :measurement, :range_check)\n    connect!(dag, [:mean_check, :variance_check, :range_check], :qc_status)\n\n    return dag\nend\n\n# Run quality control\ndag = create_qc_pipeline()\n\nmeasurements = [10.1, 10.2, 10.15, 10.3, 10.25]\nfit!(dag, :measurement => measurements)\n\nprintln(\"Mean: \", value(dag, :mean_check))\nprintln(\"Variance: \", value(dag, :variance_check))\nprintln(\"Range: \", value(dag, :range_check))\nprintln(\"QC Status: \", value(dag, :qc_status))","category":"section"},{"location":"examples/#Real-Time-Dashboard","page":"Examples","title":"Real-Time Dashboard","text":"Live statistics update:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_dashboard()\n    dag = StatDAG(strategy=:eager)\n\n    # Data source\n    add_node!(dag, :events, Mean())\n\n    # Dashboard panels\n    add_node!(dag, :count_panel, Sum())\n    add_node!(dag, :avg_panel, Mean())\n    add_node!(dag, :var_panel, Variance())\n    add_node!(dag, :hist_panel, Hist(10))\n\n    # Connect to all panels\n    connect!(dag, :events, :count_panel)\n    connect!(dag, :events, :avg_panel)\n    connect!(dag, :events, :var_panel)\n    connect!(dag, :events, :hist_panel)\n\n    return dag\nend\n\n# Update dashboard\ndag = create_dashboard()\n\n# Stream events\nfunction update_dashboard(dag, event_value)\n    fit!(dag, :events => event_value)\n\n    # Dashboard auto-updates (eager mode)\n    return (\n        count = value(dag, :count_panel),\n        average = value(dag, :avg_panel),\n        variance = value(dag, :var_panel),\n        histogram = value(dag, :hist_panel)\n    )\nend\n\n# Simulate events\nfor event in event_stream\n    dashboard_data = update_dashboard(dag, event)\n    display_dashboard(dashboard_data)\nend","category":"section"},{"location":"examples/#Batch-Analytics-Pipeline","page":"Examples","title":"Batch Analytics Pipeline","text":"Process large datasets efficiently:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_analytics_pipeline()\n    dag = StatDAG(strategy=:lazy)\n\n    # Data inputs\n    add_node!(dag, :dataset_a, Mean())\n    add_node!(dag, :dataset_b, Mean())\n\n    # Derived metrics\n    add_node!(dag, :metric_1, Mean())\n    add_node!(dag, :metric_2, Variance())\n\n    # Final reports\n    add_node!(dag, :report_summary, Mean())\n\n    # Build pipeline\n    connect!(dag, :dataset_a, :metric_1)\n    connect!(dag, :dataset_b, :metric_1)\n    connect!(dag, [:dataset_a, :dataset_b], :metric_2)\n    connect!(dag, [:metric_1, :metric_2], :report_summary)\n\n    return dag\nend\n\n# Process batch\ndag = create_analytics_pipeline()\n\n# Load large datasets\ndata_a = load_dataset(\"a.csv\")\ndata_b = load_dataset(\"b.csv\")\n\n# Fit (lazy - no propagation)\nfit!(dag, Dict(\n    :dataset_a => data_a,\n    :dataset_b => data_b\n))\n\n# Compute only what's needed\nreport = value(dag, :report_summary)","category":"section"},{"location":"examples/#Multi-Source-Data-Fusion","page":"Examples","title":"Multi-Source Data Fusion","text":"Combine multiple data sources:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_fusion_pipeline()\n    dag = StatDAG()\n\n    # Multiple data sources\n    add_node!(dag, :sensor_a, Mean())\n    add_node!(dag, :sensor_b, Mean())\n    add_node!(dag, :database, Mean())\n\n    # Fusion layers\n    add_node!(dag, :fused_sensors, Mean())\n    add_node!(dag, :final_estimate, Mean())\n\n    # Build fusion\n    connect!(dag, [:sensor_a, :sensor_b], :fused_sensors)\n    connect!(dag, [:fused_sensors, :database], :final_estimate)\n\n    return dag\nend\n\n# Fuse data\ndag = create_fusion_pipeline()\n\nfit!(dag, Dict(\n    :sensor_a => [10.1, 10.2],\n    :sensor_b => [10.15, 10.25],\n    :database => [10.0, 10.1, 10.2]\n))\n\nprintln(\"Fused estimate: \", value(dag, :final_estimate))","category":"section"},{"location":"examples/#Strategy-Switching-Example","page":"Examples","title":"Strategy Switching Example","text":"Dynamic strategy changes:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG(strategy=:eager)\n\nadd_node!(dag, :input, Mean())\nadd_node!(dag, :output, Mean())\nconnect!(dag, :input, :output)\n\n# Real-time mode (eager)\nprintln(\"Real-time processing...\")\nfor x in realtime_stream\n    fit!(dag, :input => x)\n    display(value(dag, :output))\nend\n\n# Switch to batch mode (lazy)\nprintln(\"Switching to batch mode...\")\nset_strategy!(dag, :lazy)\n\n# Process batch (no propagation)\nfit!(dag, :input => batch_data)\n\n# Compute when ready\nresult = value(dag, :output)","category":"section"},{"location":"examples/#Edge-Transformations","page":"Examples","title":"Edge Transformations","text":"","category":"section"},{"location":"examples/#Temperature-Conversion","page":"Examples","title":"Temperature Conversion","text":"Convert temperature units on-the-fly:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\n# Sensor outputs in Celsius\nadd_node!(dag, :celsius, Mean())\nadd_node!(dag, :fahrenheit, Mean())\nadd_node!(dag, :kelvin, Mean())\n\n# Convert to different scales\nconnect!(dag, :celsius, :fahrenheit, transform = c -> c * 9/5 + 32)\nconnect!(dag, :celsius, :kelvin, transform = c -> c + 273.15)\n\n# Input temperature readings\nfit!(dag, :celsius => [0.0, 10.0, 20.0, 30.0, 40.0])\n\nprintln(\"Celsius: \", value(dag, :celsius))       # 20.0°C\nprintln(\"Fahrenheit: \", value(dag, :fahrenheit)) # 68.0°F\nprintln(\"Kelvin: \", value(dag, :kelvin))         # 293.15K","category":"section"},{"location":"examples/#Data-Cleaning-Pipeline","page":"Examples","title":"Data Cleaning Pipeline","text":"Filter and transform data:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :raw_sensor, Mean())\nadd_node!(dag, :valid_only, Mean())\nadd_node!(dag, :calibrated, Mean())\n\n# Filter out missing values\nconnect!(dag, :raw_sensor, :valid_only, filter = !ismissing)\n\n# Apply calibration after filtering\nconnect!(dag, :valid_only, :calibrated, transform = x -> x * 1.05 + 0.5)\n\n# Input with some missing values\nfit!(dag, :raw_sensor => [10.0, missing, 15.0, missing, 20.0])\n\nprintln(\"Valid readings: \", value(dag, :valid_only))    # 15.0\nprintln(\"Calibrated: \", value(dag, :calibrated))        # 16.25","category":"section"},{"location":"examples/#E-Commerce-Analytics","page":"Examples","title":"E-Commerce Analytics","text":"Extract metrics from transaction data:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\n# Transaction structure\nstruct Transaction\n    price::Float64\n    quantity::Int\n    discount::Float64\nend\n\ndag = StatDAG()\n\nadd_node!(dag, :transactions, Mean())\nadd_node!(dag, :avg_price, Mean())\nadd_node!(dag, :avg_quantity, Mean())\nadd_node!(dag, :total_revenue, Mean())\n\n# Extract different metrics\nconnect!(dag, :transactions, :avg_price, \n         transform = t -> t.price)\n\nconnect!(dag, :transactions, :avg_quantity, \n         transform = t -> Float64(t.quantity))\n\nconnect!(dag, :transactions, :total_revenue, \n         transform = t -> t.price * t.quantity * (1 - t.discount))\n\n# Process transactions\ntransactions = [\n    Transaction(100.0, 2, 0.1),\n    Transaction(150.0, 1, 0.0),\n    Transaction(75.0, 3, 0.2)\n]\n\nfit!(dag, :transactions => transactions)\n\nprintln(\"Average price: \", value(dag, :avg_price))\nprintln(\"Average quantity: \", value(dag, :avg_quantity))\nprintln(\"Average revenue: \", value(dag, :total_revenue))","category":"section"},{"location":"examples/#Conditional-Routing-with-Transforms","page":"Examples","title":"Conditional Routing with Transforms","text":"Route data based on conditions:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :temperature, Mean())\nadd_node!(dag, :high_alert, Mean())\nadd_node!(dag, :normal, Mean())\nadd_node!(dag, :low_alert, Mean())\n\n# High temperature alert (>30°C) - convert to Fahrenheit\nconnect!(dag, :temperature, :high_alert,\n         filter = t -> t > 30,\n         transform = t -> t * 9/5 + 32)\n\n# Normal range (10-30°C) - keep as is\nconnect!(dag, :temperature, :normal,\n         filter = t -> 10 <= t <= 30)\n\n# Low temperature alert (<10°C) - flag with negative\nconnect!(dag, :temperature, :low_alert,\n         filter = t -> t < 10,\n         transform = t -> -t)\n\n# Stream temperature data\nfit!(dag, :temperature => [5.0, 15.0, 25.0, 35.0, 8.0, 32.0])\n\nprintln(\"High alerts (°F): \", value(dag, :high_alert))  # Avg of 95°F, 89.6°F\nprintln(\"Normal temps: \", value(dag, :normal))          # Avg of 15, 25\nprintln(\"Low alerts: \", value(dag, :low_alert))         # Avg of -5, -8","category":"section"},{"location":"examples/#Multi-Input-Feature-Engineering","page":"Examples","title":"Multi-Input Feature Engineering","text":"Combine multiple inputs with transformations:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :price, Mean())\nadd_node!(dag, :volume, Mean())\nadd_node!(dag, :momentum, Mean())\n\n# Calculate momentum: price * volume\nconnect!(dag, [:price, :volume], :momentum,\n         transform = inputs -> inputs[1] * inputs[2])\n\n# Update with coordinated data\nfit!(dag, Dict(\n    :price => [100.0, 105.0, 103.0],\n    :volume => [1000.0, 1200.0, 900.0]\n))\n\nprintln(\"Average price: \", value(dag, :price))\nprintln(\"Average volume: \", value(dag, :volume))\nprintln(\"Average momentum: \", value(dag, :momentum))","category":"section"},{"location":"examples/#Log-Transform-Pipeline","page":"Examples","title":"Log Transform Pipeline","text":"Apply logarithmic transformations:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :population, Mean())\nadd_node!(dag, :log_population, Mean())\nadd_node!(dag, :growth_rate, Mean())\n\n# Log transform\nconnect!(dag, :population, :log_population,\n         transform = p -> log10(p))\n\n# Calculate growth rate (only for positive changes)\nconnect!(dag, :log_population, :growth_rate,\n         filter = x -> x > 0)\n\n# Population data\nfit!(dag, :population => [1000.0, 1100.0, 1210.0, 1331.0])\n\nprintln(\"Mean population: \", value(dag, :population))\nprintln(\"Mean log(pop): \", value(dag, :log_population))\nprintln(\"Growth rate: \", value(dag, :growth_rate))","category":"section"},{"location":"examples/#See-Also","page":"Examples","title":"See Also","text":"Basic Tutorial - Fundamental concepts\nAdvanced Patterns - Complex structures\nPerformance Guide - Optimization\nAPI Reference - Complete documentation","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Requirements","page":"Installation","title":"Requirements","text":"Julia 1.10 or later\nOnlineStatsBase.jl","category":"section"},{"location":"installation/#Installing-from-Package-Registry","page":"Installation","title":"Installing from Package Registry","text":"Once registered, install OnlineStatsChains.jl using Julia's package manager:\n\nusing Pkg\nPkg.add(\"OnlineStatsChains\")","category":"section"},{"location":"installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"To install the development version:\n\nusing Pkg\nPkg.develop(url=\"https://github.com/femtotrader/OnlineStatsChains.jl\")\n\nOr from a local path:\n\nusing Pkg\nPkg.develop(path=\"/path/to/OnlineStatsChains\")","category":"section"},{"location":"installation/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"Test that the package is correctly installed:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\n# Create a simple DAG\ndag = StatDAG()\nadd_node!(dag, :test, Mean())\nfit!(dag, :test => 1.0)\n\nprintln(\"Installation successful! Value: \", value(dag, :test))","category":"section"},{"location":"installation/#Dependencies","page":"Installation","title":"Dependencies","text":"OnlineStatsChains.jl depends on:\n\nOnlineStatsBase.jl - Provides the base OnlineStat types","category":"section"},{"location":"installation/#Optional-Dependencies","page":"Installation","title":"Optional Dependencies","text":"For documentation:\n\nDocumenter.jl\n\nFor testing:\n\nTest (Julia standard library)","category":"section"},{"location":"installation/#Compatibility","page":"Installation","title":"Compatibility","text":"Julia: 1.10+\nOnlineStatsBase: 1.x","category":"section"},{"location":"installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"installation/#Common-Issues","page":"Installation","title":"Common Issues","text":"Issue: Package not found Solution: Make sure you're using Julia 1.10 or later and have an up-to-date package registry.\n\nusing Pkg\nPkg.update()\nPkg.add(\"OnlineStatsChains\")\n\nIssue: Method errors with OnlineStats Solution: Ensure you have compatible versions of OnlineStatsBase.jl installed.\n\nusing Pkg\nPkg.status(\"OnlineStatsBase\")","category":"section"},{"location":"installation/#Getting-Help","page":"Installation","title":"Getting Help","text":"If you encounter issues:\n\nCheck the GitHub Issues\nRead the FAQ\nAsk on Julia Discourse","category":"section"},{"location":"tutorials/basic/#Basic-Usage-Tutorial","page":"Basic Usage","title":"Basic Usage Tutorial","text":"This tutorial covers the fundamental concepts of OnlineStatsChains.jl.","category":"section"},{"location":"tutorials/basic/#Understanding-DAGs","page":"Basic Usage","title":"Understanding DAGs","text":"A Directed Acyclic Graph (DAG) is a graph with directed edges and no cycles. In OnlineStatsChains:\n\nNodes contain OnlineStats\nEdges define data flow direction\nNo cycles ensures predictable execution order","category":"section"},{"location":"tutorials/basic/#Creating-Your-First-DAG","page":"Basic Usage","title":"Creating Your First DAG","text":"","category":"section"},{"location":"tutorials/basic/#Step-1:-Import-Packages","page":"Basic Usage","title":"Step 1: Import Packages","text":"using OnlineStatsChains\nusing OnlineStatsBase  # For Mean, Variance, etc.","category":"section"},{"location":"tutorials/basic/#Step-2:-Create-a-DAG","page":"Basic Usage","title":"Step 2: Create a DAG","text":"dag = StatDAG()\n\nYou can also specify an evaluation strategy:\n\ndag = StatDAG(strategy=:eager)   # Default\ndag = StatDAG(strategy=:lazy)    # Lazy evaluation\ndag = StatDAG(strategy=:partial) # Partial evaluation","category":"section"},{"location":"tutorials/basic/#Step-3:-Add-Nodes","page":"Basic Usage","title":"Step 3: Add Nodes","text":"Each node wraps an OnlineStat:\n\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :extrema, Extrema())\n\nNode IDs must be unique Symbols:\n\nadd_node!(dag, :node1, Mean())  # ✓ OK\nadd_node!(dag, :node1, Mean())  # ✗ Error: already exists","category":"section"},{"location":"tutorials/basic/#Step-4:-Connect-Nodes","page":"Basic Usage","title":"Step 4: Connect Nodes","text":"Create directed edges between nodes:\n\nconnect!(dag, :source, :variance)\nconnect!(dag, :source, :extrema)\n\nThis creates the graph:\n\nsource → variance\n   ↓\nextrema","category":"section"},{"location":"tutorials/basic/#Step-5:-Fit-Data","page":"Basic Usage","title":"Step 5: Fit Data","text":"Feed data to source nodes:\n\n# Single value\nfit!(dag, :source => 1.0)\nfit!(dag, :source => 2.0)\n\n# Batch (array)\nfit!(dag, :source => [3.0, 4.0, 5.0])","category":"section"},{"location":"tutorials/basic/#Step-6:-Retrieve-Values","page":"Basic Usage","title":"Step 6: Retrieve Values","text":"Get computed statistics:\n\nprintln(\"Mean: \", value(dag, :source))\nprintln(\"Variance: \", value(dag, :variance))\nprintln(\"Extrema: \", value(dag, :extrema))","category":"section"},{"location":"tutorials/basic/#Data-Flow-Modes","page":"Basic Usage","title":"Data Flow Modes","text":"","category":"section"},{"location":"tutorials/basic/#Streaming-Mode","page":"Basic Usage","title":"Streaming Mode","text":"Process one value at a time:\n\ndag = StatDAG()\nadd_node!(dag, :stream, Mean())\n\nfor x in randn(1000)\n    fit!(dag, :stream => x)\nend\n\nprintln(\"Streaming mean: \", value(dag, :stream))","category":"section"},{"location":"tutorials/basic/#Batch-Mode","page":"Basic Usage","title":"Batch Mode","text":"Process entire arrays:\n\ndag = StatDAG()\nadd_node!(dag, :batch, Mean())\n\ndata = randn(1000)\nfit!(dag, :batch => data)\n\nprintln(\"Batch mean: \", value(dag, :batch))","category":"section"},{"location":"tutorials/basic/#Evaluation-Strategies","page":"Basic Usage","title":"Evaluation Strategies","text":"","category":"section"},{"location":"tutorials/basic/#Eager-Evaluation","page":"Basic Usage","title":"Eager Evaluation","text":"Default behavior - propagates immediately:\n\ndag = StatDAG(strategy=:eager)\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)\n# :b is immediately updated\n\nvalue(dag, :b)  # Already computed","category":"section"},{"location":"tutorials/basic/#Lazy-Evaluation","page":"Basic Usage","title":"Lazy Evaluation","text":"Defers computation until needed:\n\ndag = StatDAG(strategy=:lazy)\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)\n# :b is NOT updated yet\n\nvalue(dag, :b)  # Triggers computation NOW","category":"section"},{"location":"tutorials/basic/#Switching-Strategies","page":"Basic Usage","title":"Switching Strategies","text":"Change strategy dynamically:\n\ndag = StatDAG(strategy=:eager)\n# ... use dag ...\n\nset_strategy!(dag, :lazy)\n# Now uses lazy evaluation","category":"section"},{"location":"tutorials/basic/#Working-with-Multiple-Sources","page":"Basic Usage","title":"Working with Multiple Sources","text":"Update multiple source nodes:\n\ndag = StatDAG()\nadd_node!(dag, :input1, Mean())\nadd_node!(dag, :input2, Mean())\nadd_node!(dag, :output, Mean())\n\nconnect!(dag, :input1, :output)\nconnect!(dag, :input2, :output)\n\n# Update both sources\nfit!(dag, Dict(\n    :input1 => 10.0,\n    :input2 => 20.0\n))","category":"section"},{"location":"tutorials/basic/#Error-Handling","page":"Basic Usage","title":"Error Handling","text":"OnlineStatsChains provides clear error messages:\n\n# Duplicate node\nadd_node!(dag, :test, Mean())\nadd_node!(dag, :test, Mean())\n# Error: ArgumentError: Node :test already exists\n\n# Non-existent node\nconnect!(dag, :a, :nonexistent)\n# Error: ArgumentError: Node :nonexistent does not exist\n\n# Cycle detection\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nadd_node!(dag, :c, Mean())\nconnect!(dag, :a, :b)\nconnect!(dag, :b, :c)\nconnect!(dag, :c, :a)\n# Error: CycleError: Adding edge :c -> :a would create a cycle","category":"section"},{"location":"tutorials/basic/#Introspection","page":"Basic Usage","title":"Introspection","text":"Examine your DAG structure:\n\n# List all nodes\nnodes = get_nodes(dag)\n\n# Get node relationships\nparents = get_parents(dag, :node_id)\nchildren = get_children(dag, :node_id)\n\n# Get execution order\norder = get_topological_order(dag)\n\n# Validate DAG\nvalidate(dag)  # Returns true if valid","category":"section"},{"location":"tutorials/basic/#Complete-Example","page":"Basic Usage","title":"Complete Example","text":"Putting it all together:\n\nusing OnlineStatsChains\nusing OnlineStatsBase\n\n# Create DAG\ndag = StatDAG()\n\n# Build structure\nadd_node!(dag, :prices, Mean())\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :range, Extrema())\n\nconnect!(dag, :prices, :variance)\nconnect!(dag, :prices, :range)\n\n# Process data\nprices = [100.0, 102.0, 101.0, 103.0, 105.0]\nfit!(dag, :prices => prices)\n\n# Results\nprintln(\"Average price: \", value(dag, :prices))\nprintln(\"Price variance: \", value(dag, :variance))\nprintln(\"Price range: \", value(dag, :range))","category":"section"},{"location":"tutorials/basic/#Next-Steps","page":"Basic Usage","title":"Next Steps","text":"Advanced Patterns - Complex DAG structures\nPerformance Guide - Optimization techniques\nAPI Reference - Complete documentation","category":"section"},{"location":"#OnlineStatsChains.jl-Documentation","page":"Home","title":"OnlineStatsChains.jl Documentation","text":"warning: AI-Generated Package\nThis package was entirely generated using Claude Code (AI).Please read the ⚠️ AI-Generated Notice carefully before using in production.While the package includes comprehensive tests and documentation, users should:Review the code for their use case\nAdd application-specific tests\nReport any issues foundSee the full notice for security considerations and recommended due diligence.\n\nA Julia package for chaining OnlineStats computations in a Directed Acyclic Graph (DAG) structure with automatic value propagation.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"OnlineStatsChains.jl provides a powerful framework for building computational pipelines where OnlineStats are automatically updated as data flows through a directed acyclic graph.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"📊 DAG Construction: Build computational graphs with automatic cycle detection\n⚡ Three Evaluation Strategies:\nEager (default): Immediate propagation when fit!() is called\nLazy: Deferred computation until value() is requested\nPartial: Optimized propagation for affected subgraphs only\n🔀 Multi-Input Nodes: Support for fan-in and fan-out patterns\n📈 Batch & Streaming: Process data element-by-element or in batches\n🔧 Type-Safe: Works with any OnlineStat from OnlineStatsBase.jl","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Create a computational DAG\ndag = StatDAG()\n\n# Add nodes\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :variance, Variance())\n\n# Connect nodes\nconnect!(dag, :source, :variance)\n\n# Fit data (propagates automatically)\nfit!(dag, :source => [1.0, 2.0, 3.0, 4.0, 5.0])\n\n# Get results\nprintln(\"Mean: \", value(dag, :source))       # 3.0\nprintln(\"Variance: \", value(dag, :variance))","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"installation.md\",\n    \"quickstart.md\",\n    \"tutorials/basic.md\",\n    \"tutorials/advanced.md\",\n    \"tutorials/performance.md\",\n    \"api.md\",\n    \"examples.md\",\n]\nDepth = 2","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"}]
}
