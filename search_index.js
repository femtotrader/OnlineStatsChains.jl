var documenterSearchIndex = {"docs":
[{"location":"tutorials/performance/#Performance-Considerations","page":"Performance","title":"Performance Considerations","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"This guide covers performance optimization techniques for OnlineStatsChains.jl.","category":"page"},{"location":"tutorials/performance/#Algorithmic-Complexity","page":"Performance","title":"Algorithmic Complexity","text":"","category":"section"},{"location":"tutorials/performance/#Core-Operations","page":"Performance","title":"Core Operations","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"OnlineStatsChains is designed for efficiency:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Operation Complexity Description\nCycle Detection O(V + E) DFS-based algorithm\nTopological Sort O(V + E) Kahn's algorithm\nPropagation O(V + E) Per update in eager mode\nAdd Node O(1) Amortized constant time\nConnect Nodes O(V + E) Includes cycle check","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Where:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"V = number of vertices (nodes)\nE = number of edges (connections)","category":"page"},{"location":"tutorials/performance/#Memory-Usage","page":"Performance","title":"Memory Usage","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Memory overhead per node is minimal:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Node struct: ~100 bytes\nTopological cache: O(V)\nDirty set (lazy mode): O(V)","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"For large graphs (1000+ nodes), memory footprint remains manageable.","category":"page"},{"location":"tutorials/performance/#Choosing-Evaluation-Strategies","page":"Performance","title":"Choosing Evaluation Strategies","text":"","category":"section"},{"location":"tutorials/performance/#Eager-Evaluation","page":"Performance","title":"Eager Evaluation","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Best for:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Real-time processing\nSmall to medium DAGs\nStreaming data\nWhen all nodes need updates","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Characteristics:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Immediate propagation\nNo deferred computation\nPredictable latency\nHigher throughput for dense updates","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"dag = StatDAG(strategy=:eager)\n# Good for: streaming sensors, real-time dashboards","category":"page"},{"location":"tutorials/performance/#Lazy-Evaluation","page":"Performance","title":"Lazy Evaluation","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Best for:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Large DAGs\nSparse queries\nBatch processing\nWhen only some results are needed","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Characteristics:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Deferred computation\nCompute only what's requested\nLower memory pressure\nBetter for selective access","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"dag = StatDAG(strategy=:lazy)\n# Good for: large analytics pipelines, selective queries","category":"page"},{"location":"tutorials/performance/#Partial-Evaluation","page":"Performance","title":"Partial Evaluation","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Best for:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Large DAGs with independent branches\nWhen updates affect limited subgraphs\nAvoiding unnecessary recomputation","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Characteristics:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Selective propagation\nOptimized for sparse updates\nReduced computation for unchanged branches","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"dag = StatDAG(strategy=:partial)\n# Good for: multi-branch analytics, parallel streams","category":"page"},{"location":"tutorials/performance/#Performance-Tips","page":"Performance","title":"Performance Tips","text":"","category":"section"},{"location":"tutorials/performance/#1.-Batch-Updates","page":"Performance","title":"1. Batch Updates","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Process data in batches when possible:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Slow - many small updates\nfor x in data\n    fit!(dag, :source => x)\nend\n\n# Fast - batch update\nfit!(dag, :source => data)","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Speedup: 10-100x for large datasets","category":"page"},{"location":"tutorials/performance/#2.-Minimize-Connections","page":"Performance","title":"2. Minimize Connections","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Fewer edges = faster propagation:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Slower - deeply nested chain\nconnect!(dag, :a, :b)\nconnect!(dag, :b, :c)\nconnect!(dag, :c, :d)\n# ... many levels\n\n# Faster - flatter structure when possible\nconnect!(dag, :input, :output1)\nconnect!(dag, :input, :output2)","category":"page"},{"location":"tutorials/performance/#3.-Use-Lazy-for-Selective-Access","page":"Performance","title":"3. Use Lazy for Selective Access","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"When querying only some nodes:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Eager: computes all 100 nodes\ndag = StatDAG(strategy=:eager)\nfor i in 1:100\n    add_node!(dag, Symbol(\"n\", i), Mean())\n    i > 1 && connect!(dag, Symbol(\"n\", i-1), Symbol(\"n\", i))\nend\nfit!(dag, :n1 => data)  # Updates all 100\n\n# Lazy: computes only what's needed\ndag = StatDAG(strategy=:lazy)\n# ... same structure ...\nfit!(dag, :n1 => data)  # No propagation\nvalue(dag, :n100)  # Computes only path to n100","category":"page"},{"location":"tutorials/performance/#4.-Reuse-DAGs","page":"Performance","title":"4. Reuse DAGs","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Creating DAGs has overhead - reuse when possible:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Initialize once\ndag = create_analysis_pipeline()\n\n# Reuse many times\nfor batch in data_stream\n    fit!(dag, :input => batch)\n    results = value(dag, :output)\nend","category":"page"},{"location":"tutorials/performance/#5.-Pre-allocate-for-Known-Patterns","page":"Performance","title":"5. Pre-allocate for Known Patterns","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Build DAG structure before data processing:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Good: structure first, data later\ndag = StatDAG()\nbuild_dag_structure!(dag)\n\nfor data in stream\n    fit!(dag, :input => data)\nend\n\n# Avoid: mixing structure changes with data\nfor data in stream\n    add_node!(dag, random_name(), Mean())  # Bad!\n    fit!(dag, :input => data)\nend","category":"page"},{"location":"tutorials/performance/#Benchmarking","page":"Performance","title":"Benchmarking","text":"","category":"section"},{"location":"tutorials/performance/#Measuring-Performance","page":"Performance","title":"Measuring Performance","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"using BenchmarkTools\n\n# Create DAG\ndag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :sink, Mean())\nconnect!(dag, :source, :sink)\n\ndata = randn(1000)\n\n# Benchmark\n@benchmark fit!($dag, :source => $data)","category":"page"},{"location":"tutorials/performance/#Comparing-Strategies","page":"Performance","title":"Comparing Strategies","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"using BenchmarkTools\n\nfunction benchmark_strategies(n_nodes::Int, data_size::Int)\n    data = randn(data_size)\n\n    for strategy in [:eager, :lazy, :partial]\n        dag = StatDAG(strategy=strategy)\n\n        # Build chain\n        for i in 1:n_nodes\n            add_node!(dag, Symbol(\"n\", i), Mean())\n            i > 1 && connect!(dag, Symbol(\"n\", i-1), Symbol(\"n\", i))\n        end\n\n        # Benchmark\n        println(\"Strategy: $strategy\")\n        @btime fit!($dag, :n1 => $data)\n        @btime value($dag, Symbol(\"n\", $n_nodes))\n    end\nend\n\nbenchmark_strategies(10, 1000)","category":"page"},{"location":"tutorials/performance/#Memory-Optimization","page":"Performance","title":"Memory Optimization","text":"","category":"section"},{"location":"tutorials/performance/#1.-Clear-Caches-Periodically","page":"Performance","title":"1. Clear Caches Periodically","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"For long-running processes:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# After processing many batches\ndag = StatDAG()\n# ... process lots of data ...\n\n# Manually trigger garbage collection if needed\nGC.gc()","category":"page"},{"location":"tutorials/performance/#2.-Lazy-for-Memory-Constrained-Environments","page":"Performance","title":"2. Lazy for Memory-Constrained Environments","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Lazy evaluation reduces memory pressure:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Eager: all nodes cache values\ndag_eager = StatDAG(strategy=:eager)\n\n# Lazy: only computed nodes cache\ndag_lazy = StatDAG(strategy=:lazy)\nfit!(dag_lazy, :input => data)\n# Memory used: only :input and its stat","category":"page"},{"location":"tutorials/performance/#3.-Streaming-for-Large-Datasets","page":"Performance","title":"3. Streaming for Large Datasets","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Process in chunks to control memory:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"dag = StatDAG()\nadd_node!(dag, :processor, Mean())\n\nchunk_size = 1000\nfor chunk in Iterators.partition(huge_dataset, chunk_size)\n    fit!(dag, :processor => collect(chunk))\nend","category":"page"},{"location":"tutorials/performance/#Profiling","page":"Performance","title":"Profiling","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Identify bottlenecks:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"using Profile\n\ndag = create_complex_dag()\ndata = generate_test_data()\n\n@profile for _ in 1:100\n    fit!(dag, :input => data)\nend\n\nProfile.print()","category":"page"},{"location":"tutorials/performance/#Common-Performance-Pitfalls","page":"Performance","title":"Common Performance Pitfalls","text":"","category":"section"},{"location":"tutorials/performance/#Avoid","page":"Performance","title":"❌ Avoid","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# 1. Many small DAG modifications\nfor data_point in stream\n    dag = StatDAG()  # Don't recreate!\n    add_node!(dag, :temp, Mean())\n    fit!(dag, :temp => data_point)\nend\n\n# 2. Unnecessary value() calls in loops\nfor data in batches\n    fit!(dag, :input => data)\n    v = value(dag, :output)  # Don't query every iteration\nend\n\n# 3. Deep chains when parallel structure works\n# a → b → c → d → e  (slow)\n# Better: a → [b, c, d, e]  (fast)","category":"page"},{"location":"tutorials/performance/#Do","page":"Performance","title":"✅ Do","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# 1. Reuse DAG structure\ndag = StatDAG()\nadd_node!(dag, :processor, Mean())\n\nfor data_point in stream\n    fit!(dag, :processor => data_point)\nend\n\n# 2. Batch queries\nfor data in batches\n    fit!(dag, :input => data)\nend\nresult = value(dag, :output)  # Query once\n\n# 3. Use appropriate structure\ndag = StatDAG()\nadd_node!(dag, :input, Mean())\nfor i in 1:n\n    add_node!(dag, Symbol(\"out\", i), Mean())\n    connect!(dag, :input, Symbol(\"out\", i))\nend","category":"page"},{"location":"tutorials/performance/#Scaling-to-Large-Graphs","page":"Performance","title":"Scaling to Large Graphs","text":"","category":"section"},{"location":"tutorials/performance/#Handling-1000-Nodes","page":"Performance","title":"Handling 1000+ Nodes","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"# Lazy evaluation is crucial\ndag = StatDAG(strategy=:lazy)\n\n# Batch node creation\nfunction build_large_dag(n::Int)\n    dag = StatDAG(strategy=:lazy)\n\n    # Add nodes efficiently\n    for i in 1:n\n        add_node!(dag, Symbol(\"n\", i), Mean())\n    end\n\n    # Add connections\n    for i in 1:n-1\n        connect!(dag, Symbol(\"n\", i), Symbol(\"n\", i+1))\n    end\n\n    return dag\nend\n\nlarge_dag = build_large_dag(5000)","category":"page"},{"location":"tutorials/performance/#Parallel-Processing-(Future)","page":"Performance","title":"Parallel Processing (Future)","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Current version is single-threaded. Future versions may support:","category":"page"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"Parallel branch execution\nMulti-threaded propagation\nDistributed computing","category":"page"},{"location":"tutorials/performance/#Optimization-Checklist","page":"Performance","title":"Optimization Checklist","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"[ ] Use appropriate evaluation strategy\n[ ] Batch data updates when possible\n[ ] Reuse DAG structures\n[ ] Minimize graph depth\n[ ] Profile before optimizing\n[ ] Consider memory vs. speed tradeoffs\n[ ] Use lazy for large selective queries\n[ ] Pre-build DAG structure","category":"page"},{"location":"tutorials/performance/#Next-Steps","page":"Performance","title":"Next Steps","text":"","category":"section"},{"location":"tutorials/performance/","page":"Performance","title":"Performance","text":"API Reference - Complete documentation\nExamples - Real-world use cases\nBasic Tutorial - Fundamental concepts","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete API documentation for OnlineStatsChains.jl.","category":"page"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#StatDAG","page":"API Reference","title":"StatDAG","text":"","category":"section"},{"location":"api/#OnlineStatsChains.StatDAG","page":"API Reference","title":"OnlineStatsChains.StatDAG","text":"StatDAG(; strategy=:eager)\n\nCreate a new Directed Acyclic Graph (DAG) for chaining OnlineStat computations.\n\nFields\n\nnodes: Dictionary mapping node IDs to Node instances\nedges: Dictionary mapping (from, to) tuples to Edge instances\ntopological_order: Cached topological ordering of nodes\norder_valid: Flag indicating if topological order is current\nstrategy: Evaluation strategy (:eager, :lazy, or :partial)\ndirty_nodes: Set of nodes that need recomputation (lazy mode)\n\nEvaluation Strategies\n\n:eager (default): Propagation happens immediately when fit!() is called\n:lazy: Updates are recorded but not propagated until value() is requested\n:partial: Only affected subgraph is recomputed\n\nExample\n\n# Eager evaluation (default)\ndag = StatDAG()\n\n# Lazy evaluation\ndag = StatDAG(strategy=:lazy)\n\n# Partial evaluation\ndag = StatDAG(strategy=:partial)\n\n\n\n\n\n","category":"type"},{"location":"api/#CycleError","page":"API Reference","title":"CycleError","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Custom exception type raised when attempting to create a cycle in the DAG.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Type: CycleError <: Exception","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Fields:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"msg::String - Error message describing the cycle","category":"page"},{"location":"api/#DAG-Construction","page":"API Reference","title":"DAG Construction","text":"","category":"section"},{"location":"api/#OnlineStatsChains.add_node!","page":"API Reference","title":"OnlineStatsChains.add_node!","text":"add_node!(dag::StatDAG, id::Symbol, stat::OnlineStat)\n\nAdd a node to the DAG with the given identifier and OnlineStat instance.\n\nThrows ArgumentError if a node with the same id already exists.\n\nArguments\n\ndag: The StatDAG instance\nid: Unique symbol identifier for the node\nstat: An OnlineStat instance to associate with this node\n\nExample\n\ndag = StatDAG()\nadd_node!(dag, :mean, Mean())\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.connect!","page":"API Reference","title":"OnlineStatsChains.connect!","text":"connect!(dag::StatDAG, from_id::Symbol, to_id::Symbol; filter::Union{Function,Nothing}=nothing, transform::Union{Function,Nothing}=nothing)\n\nCreate a directed edge from from_id node to to_id node.\n\nThrows ArgumentError if either node doesn't exist. Throws CycleError if the connection would create a cycle.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\nfilter: Optional filter function to conditionally propagate values\ntransform: Optional transform function to modify values before propagation\n\nWhen both filter and transform are provided, the filter is evaluated first. The transform is only applied if the filter returns true.\n\nExample\n\nconnect!(dag, :source, :sink)\nconnect!(dag, :ema1, :ema2, filter = !ismissing)\nconnect!(dag, :price, :alert, filter = x -> x > 100)\nconnect!(dag, :raw, :scaled, transform = x -> x * 100)\nconnect!(dag, :temp_c, :temp_f, filter = !ismissing, transform = c -> c * 9/5 + 32)\n\n\n\n\n\nconnect!(dag::StatDAG, from_ids::Vector{Symbol}, to_id::Symbol; filter::Union{Function,Nothing}=nothing, transform::Union{Function,Nothing}=nothing)\n\nConnect multiple source nodes to a single destination node (fan-in).\n\nArguments\n\ndag: The StatDAG instance\nfrom_ids: Vector of source node identifiers\nto_id: Destination node identifier\nfilter: Optional filter function applied to combined parent values\ntransform: Optional transform function applied to combined parent values\n\nExample\n\nconnect!(dag, [:input1, :input2], :combined)\nconnect!(dag, [:high, :low], :spread, filter = vals -> all(!ismissing, vals))\nconnect!(dag, [:price, :qty], :total, transform = vals -> vals[1] * vals[2])\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Input","page":"API Reference","title":"Data Input","text":"","category":"section"},{"location":"api/#StatsAPI.fit!","page":"API Reference","title":"StatsAPI.fit!","text":"fit!(dag::StatDAG, data::Pair{Symbol, <:Any})\n\nUpdate a source node with data and propagate through the DAG.\n\nArguments\n\ndag: The StatDAG instance\ndata: A Pair of node_id => value or node_id => iterable\n\nIf value is iterable, each element is processed sequentially with propagation.\n\nExample\n\n# Single value\nfit!(dag, :source => 42)\n\n# Batch mode\nfit!(dag, :source => [1, 2, 3, 4, 5])\n\n\n\n\n\nfit!(dag::StatDAG, data::Dict{Symbol, <:Any})\n\nUpdate multiple source nodes simultaneously.\n\nIf values in the Dict are iterables of different lengths, processes up to the shortest length and issues a warning.\n\nExample\n\nfit!(dag, Dict(:input1 => [1, 2, 3], :input2 => [4, 5, 6]))\n\n\n\n\n\n","category":"function"},{"location":"api/#Value-Retrieval","page":"API Reference","title":"Value Retrieval","text":"","category":"section"},{"location":"api/#value","page":"API Reference","title":"value","text":"","category":"section"},{"location":"api/#OnlineStatsBase.value-Tuple{StatDAG, Symbol}","page":"API Reference","title":"OnlineStatsBase.value","text":"value(dag::StatDAG, id::Symbol)\n\nGet the current value of a node's OnlineStat.\n\nIn lazy mode, this triggers recomputation of dirty nodes if necessary.\n\nThrows KeyError if the node doesn't exist.\n\nExample\n\nval = value(dag, :mean)\n\n\n\n\n\n","category":"method"},{"location":"api/#values","page":"API Reference","title":"values","text":"","category":"section"},{"location":"api/#OnlineStatsChains.values","page":"API Reference","title":"OnlineStatsChains.values","text":"values(dag::StatDAG)\n\nGet a dictionary of all node values.\n\nExample\n\nall_vals = values(dag)\n\n\n\n\n\n","category":"function"},{"location":"api/#Evaluation-Strategies","page":"API Reference","title":"Evaluation Strategies","text":"","category":"section"},{"location":"api/#OnlineStatsChains.set_strategy!","page":"API Reference","title":"OnlineStatsChains.set_strategy!","text":"set_strategy!(dag::StatDAG, strategy::Symbol)\n\nChange the evaluation strategy of an existing DAG.\n\nArguments\n\ndag: The StatDAG instance\nstrategy: New strategy (:eager, :lazy, or :partial)\n\nExample\n\ndag = StatDAG()  # Default eager\nset_strategy!(dag, :lazy)  # Switch to lazy\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.invalidate!","page":"API Reference","title":"OnlineStatsChains.invalidate!","text":"invalidate!(dag::StatDAG, id::Symbol)\n\nMark a node and all its descendants as needing recomputation (lazy mode).\n\nArguments\n\ndag: The StatDAG instance\nid: Node identifier to invalidate\n\nExample\n\ndag = StatDAG(strategy=:lazy)\nadd_node!(dag, :source, Mean())\nfit!(dag, :source => 1.0)\ninvalidate!(dag, :source)  # Mark for recomputation\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.recompute!","page":"API Reference","title":"OnlineStatsChains.recompute!","text":"recompute!(dag::StatDAG)\n\nForce recomputation of all dirty nodes (lazy mode).\n\nExample\n\ndag = StatDAG(strategy=:lazy)\n# ... add nodes and fit data ...\nrecompute!(dag)  # Recompute all dirty nodes\n\n\n\n\n\n","category":"function"},{"location":"api/#Edge-Transformations","page":"API Reference","title":"Edge Transformations","text":"","category":"section"},{"location":"api/#Overview","page":"API Reference","title":"Overview","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Edge transformations allow you to apply functions to data as it flows through the DAG. This enables data preprocessing, unit conversions, feature extraction, and other transformations without modifying the source nodes.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Key Features:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Transform data on-the-fly as it propagates\nCombine with filters for conditional transformations\nSupports both single-input and multi-input transformations\nBackward compatible: edges without transforms use computed values","category":"page"},{"location":"api/#transform-parameter","page":"API Reference","title":"transform parameter","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The transform keyword argument in connect!() accepts a function that will be applied to data propagating through the edge.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Signature: connect!(dag, source, target; transform=nothing, filter=nothing)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Parameters:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"transform::Union{Function, Nothing} - Function to apply to propagating data\nfilter::Union{Function, Nothing} - Optional filter to apply before transform","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Important: When a transform or filter is present on an edge, that edge propagates raw data values instead of computed statistics. This enables meaningful transformations of the original data.","category":"page"},{"location":"api/#Basic-Example","page":"API Reference","title":"Basic Example","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using OnlineStatsChains, OnlineStats\n\n# Temperature sensor in Celsius, convert to Fahrenheit\ndag = StatDAG()\nadd_node!(dag, :celsius, Mean())\nadd_node!(dag, :fahrenheit, Mean())\n\n# Convert celsius to fahrenheit\nconnect!(dag, :celsius, :fahrenheit, transform = c -> c * 9/5 + 32)\n\n# Input temperature readings in Celsius\nfit!(dag, :celsius => [0.0, 10.0, 20.0, 30.0])\n\nvalue(dag, :celsius)      # 15.0 (mean in Celsius)\nvalue(dag, :fahrenheit)   # 59.0 (mean in Fahrenheit)","category":"page"},{"location":"api/#Data-Extraction-Example","page":"API Reference","title":"Data Extraction Example","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Extract specific fields from structured data:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"dag = StatDAG()\nadd_node!(dag, :measurements, Mean())\nadd_node!(dag, :prices, Mean())\n\n# Extract price field from measurement objects\nconnect!(dag, :measurements, :prices, transform = m -> m.price)\n\n# Simulate measurements with price and quantity\nmeasurements = [(price=10.0, qty=2), (price=15.0, qty=3), (price=12.0, qty=1)]\nfit!(dag, :measurements => measurements)","category":"page"},{"location":"api/#Combining-Filter-and-Transform","page":"API Reference","title":"Combining Filter and Transform","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Filters and transforms work together: filter is applied first, then transform.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"dag = StatDAG()\nadd_node!(dag, :temperature, Mean())\nadd_node!(dag, :fahrenheit_high, Mean())\n\n# Only propagate temperatures above 20°C, convert to Fahrenheit\nconnect!(dag, :temperature, :fahrenheit_high,\n         filter = t -> t > 20,\n         transform = t -> t * 9/5 + 32)\n\nfit!(dag, :temperature => [15.0, 25.0, 18.0, 30.0])\n# fahrenheit_high receives only [77.0, 86.0] (from 25°C and 30°C)","category":"page"},{"location":"api/#Multi-Input-Transformations","page":"API Reference","title":"Multi-Input Transformations","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Transform functions can process data from multiple parents:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"dag = StatDAG()\nadd_node!(dag, :price, Mean())\nadd_node!(dag, :quantity, Mean())\nadd_node!(dag, :revenue, Mean())\n\n# Connect multiple sources with transformation\nconnect!(dag, [:price, :quantity], :revenue,\n         transform = inputs -> inputs[1] * inputs[2])\n\nfit!(dag, Dict(:price => 10.0, :quantity => 5.0))\nvalue(dag, :revenue)  # 50.0","category":"page"},{"location":"api/#Introspection-Functions","page":"API Reference","title":"Introspection Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Query edge transformations:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Check if an edge has a transform\nhas_transform(dag::StatDAG, source::Symbol, target::Symbol) -> Bool\n\n# Get the transform function (or nothing)\nget_transform(dag::StatDAG, source::Symbol, target::Symbol) -> Union{Function, Nothing}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Example:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"dag = StatDAG()\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b, transform = x -> x * 2)\n\nhas_transform(dag, :a, :b)  # true\nget_transform(dag, :a, :b)  # returns the transform function","category":"page"},{"location":"api/#Execution-Order","page":"API Reference","title":"Execution Order","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"When both filter and transform are present on an edge:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Filter is evaluated first with the raw data value\nIf filter returns true, transform is applied\nTransformed value is fitted to the target node","category":"page"},{"location":"api/#Hybrid-Propagation-Model","page":"API Reference","title":"Hybrid Propagation Model","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"OnlineStatsChains uses a hybrid propagation model for backward compatibility:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Edges WITHOUT filter/transform: Propagate computed values (statistics like means, variances)\nEdges WITH filter OR transform: Propagate raw data values (original input data)","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This ensures existing code continues to work while enabling powerful transformations.","category":"page"},{"location":"api/#Graph-Introspection","page":"API Reference","title":"Graph Introspection","text":"","category":"section"},{"location":"api/#OnlineStatsChains.get_nodes","page":"API Reference","title":"OnlineStatsChains.get_nodes","text":"get_nodes(dag::StatDAG)\n\nGet a list of all node IDs in the DAG.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_parents","page":"API Reference","title":"OnlineStatsChains.get_parents","text":"get_parents(dag::StatDAG, id::Symbol)\n\nGet the list of parent node IDs for a given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_children","page":"API Reference","title":"OnlineStatsChains.get_children","text":"get_children(dag::StatDAG, id::Symbol)\n\nGet the list of child node IDs for a given node.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_topological_order","page":"API Reference","title":"OnlineStatsChains.get_topological_order","text":"get_topological_order(dag::StatDAG)\n\nGet the topological ordering of nodes in the DAG.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.validate","page":"API Reference","title":"OnlineStatsChains.validate","text":"validate(dag::StatDAG)\n\nValidate the DAG structure for consistency. Returns true if valid, throws an error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Filter-Introspection","page":"API Reference","title":"Filter Introspection","text":"","category":"section"},{"location":"api/#OnlineStatsChains.has_filter","page":"API Reference","title":"OnlineStatsChains.has_filter","text":"has_filter(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nCheck if an edge has a filter function.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nBool: true if the edge has a filter, false otherwise\n\nExample\n\nif has_filter(dag, :ema1, :ema2)\n    println(\"Edge has a filter\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_filter","page":"API Reference","title":"OnlineStatsChains.get_filter","text":"get_filter(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nGet the filter function for an edge, or nothing if no filter exists.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nUnion{Function, Nothing}: The filter function or nothing\n\nExample\n\nfilter_fn = get_filter(dag, :ema1, :ema2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Transform-Introspection","page":"API Reference","title":"Transform Introspection","text":"","category":"section"},{"location":"api/#OnlineStatsChains.has_transform","page":"API Reference","title":"OnlineStatsChains.has_transform","text":"has_transform(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nCheck if an edge has a transform function.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nBool: true if the edge has a transform, false otherwise\n\nExample\n\nif has_transform(dag, :raw, :scaled)\n    println(\"Edge has a transform\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.get_transform","page":"API Reference","title":"OnlineStatsChains.get_transform","text":"get_transform(dag::StatDAG, from_id::Symbol, to_id::Symbol)\n\nGet the transform function for an edge, or nothing if no transform exists.\n\nArguments\n\ndag: The StatDAG instance\nfrom_id: Source node identifier\nto_id: Destination node identifier\n\nReturns\n\nUnion{Function, Nothing}: The transform function or nothing\n\nExample\n\ntransform_fn = get_transform(dag, :raw, :scaled)\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These functions are primarily used internally but are documented for advanced usage and package development.","category":"page"},{"location":"api/#OnlineStatsChains.propagate_value!","page":"API Reference","title":"OnlineStatsChains.propagate_value!","text":"propagate_value!(dag::StatDAG, node_id::Symbol, raw_val)\n\nPropagate from a node to its immediate children.\n\nHybrid propagation model (backward compatible):\n\nIF edge has NO transform: propagates the computed value (cached_value) - ORIGINAL BEHAVIOR\nIF edge has transform: propagates the raw data through the transform - NEW BEHAVIOR\n\nThis preserves backward compatibility while enabling transformers.\n\nArguments\n\ndag: The StatDAG instance\nnode_id: The source node ID\nraw_val: The RAW input value that was just fit!() into the source node\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.has_cycle","page":"API Reference","title":"OnlineStatsChains.has_cycle","text":"has_cycle(dag::StatDAG)\n\nCheck if the DAG contains any cycles using depth-first search. Returns true if a cycle is detected, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.compute_topological_order!","page":"API Reference","title":"OnlineStatsChains.compute_topological_order!","text":"compute_topological_order!(dag::StatDAG)\n\nCompute and cache the topological ordering of nodes in the DAG. Uses Kahn's algorithm (O(V + E) complexity).\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsChains.is_ancestor","page":"API Reference","title":"OnlineStatsChains.is_ancestor","text":"is_ancestor(dag::StatDAG, potential_ancestor::Symbol, node_id::Symbol)\n\nCheck if potentialancestor is an ancestor of nodeid.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"rocket_integration/#Rocket.jl-Integration","page":"Reactive Programming","title":"Rocket.jl Integration","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"OnlineStatsChains.jl provides optional integration with Rocket.jl for reactive programming capabilities. This allows you to seamlessly combine statistical DAG computations with reactive data streams.","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"note: Optional Dependency\nRocket.jl is an optional dependency. The integration is implemented using Julia's package extension system and only loads when you explicitly install and import Rocket.jl. Core OnlineStatsChains functionality works independently without Rocket.jl.","category":"page"},{"location":"rocket_integration/#Installation","page":"Reactive Programming","title":"Installation","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"To use the Rocket.jl integration, you need to install both packages:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"using Pkg\nPkg.add(\"OnlineStatsChains\")\nPkg.add(\"Rocket\")","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Then load both packages:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket  # This activates the extension","category":"page"},{"location":"rocket_integration/#Overview","page":"Reactive Programming","title":"Overview","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"The integration provides three main patterns:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Observable → DAG (Actor pattern): Feed reactive streams into DAG nodes\nDAG → Observable (Emission pattern): Expose DAG results as reactive streams\nBidirectional: Create complete reactive pipelines through the DAG","category":"page"},{"location":"rocket_integration/#Pattern-1:-Observable-DAG-(Actor-Pattern)","page":"Reactive Programming","title":"Pattern 1: Observable → DAG (Actor Pattern)","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Use StatDAGActor to feed data from Rocket.jl Observables into DAG nodes.","category":"page"},{"location":"rocket_integration/#Basic-Example","page":"Reactive Programming","title":"Basic Example","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\n# Create DAG\ndag = StatDAG()\nadd_node!(dag, :prices, Mean())\nadd_node!(dag, :variance, Variance())\nconnect!(dag, :prices, :variance)\n\n# Create observable source\nprice_stream = from([100, 102, 101, 103, 105, 104, 106])\n\n# Create actor that feeds into DAG\nactor = StatDAGActor(dag, :prices)\n\n# Subscribe: prices flow through DAG automatically\nsubscription = subscribe!(price_stream, actor)\n\n# Check results\nprintln(\"Mean price: \", value(dag, :prices))\nprintln(\"Variance: \", value(dag, :variance))","category":"page"},{"location":"rocket_integration/#With-Filter","page":"Reactive Programming","title":"With Filter","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Filter incoming data before fitting into the DAG:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag = StatDAG()\nadd_node!(dag, :values, Mean())\n\n# Observable with some missing values\ndata = from([1.0, 2.0, missing, 3.0, missing, 4.0])\n\n# Actor with filter to exclude missing values\nactor = StatDAGActor(dag, :values, filter = !ismissing)\nsubscribe!(data, actor)\n\nprintln(value(dag, :values))  # 2.5 (only non-missing values)","category":"page"},{"location":"rocket_integration/#With-Transform","page":"Reactive Programming","title":"With Transform","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Transform incoming data before fitting:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag = StatDAG()\nadd_node!(dag, :fahrenheit, Mean())\n\n# Temperatures in Celsius\ntemps_c = from([0.0, 10.0, 20.0, 30.0])\n\n# Actor with transform: Celsius to Fahrenheit\nactor = StatDAGActor(dag, :fahrenheit,\n                     transform = c -> c * 9/5 + 32)\nsubscribe!(temps_c, actor)\n\nprintln(value(dag, :fahrenheit))  # 59.0","category":"page"},{"location":"rocket_integration/#Combined-Filter-and-Transform","page":"Reactive Programming","title":"Combined Filter and Transform","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag = StatDAG()\nadd_node!(dag, :temp_f, Mean())\n\n# Mixed data\ntemps_c = from([missing, 10.0, -300.0, 20.0, 30.0])\n\n# Filter out missing and invalid, then convert\nactor = StatDAGActor(dag, :temp_f,\n                     filter = t -> !ismissing(t) && t >= -273.15,\n                     transform = c -> c * 9/5 + 32)\nsubscribe!(temps_c, actor)\n\nprintln(value(dag, :temp_f))  # 68.0","category":"page"},{"location":"rocket_integration/#Pattern-2:-DAG-Observable-(Emission-Pattern)","page":"Reactive Programming","title":"Pattern 2: DAG → Observable (Emission Pattern)","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Use to_observable() to convert DAG nodes into Rocket.jl Observables.","category":"page"},{"location":"rocket_integration/#Basic-Example-2","page":"Reactive Programming","title":"Basic Example","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :variance, Variance())\nconnect!(dag, :source, :variance)\n\n# Create observable from variance node\nvariance_obs = to_observable(dag, :variance)\n\n# Subscribe to get notified on updates\nsubscribe!(variance_obs, lambda(\n    on_next = x -> println(\"Variance updated: \", x)\n))\n\n# Feed data - observers will be notified\nfit!(dag, :source => randn(100))","category":"page"},{"location":"rocket_integration/#Emit-Types","page":"Reactive Programming","title":"Emit Types","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Control what the Observable emits:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"# Emit computed values only (default)\nobs_computed = to_observable(dag, :variance)\n\n# Emit raw input values\nobs_raw = to_observable(dag, :variance, emit = :raw)\n\n# Emit both as tuple (raw, computed)\nobs_both = to_observable(dag, :variance, emit = :both)","category":"page"},{"location":"rocket_integration/#Multiple-Observables","page":"Reactive Programming","title":"Multiple Observables","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Create Observables from multiple nodes at once:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag = StatDAG()\nadd_node!(dag, :mean, Mean())\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :sum, Sum())\n\n# Create observables for all nodes\nobservables = to_observables(dag, [:mean, :variance, :sum])\n\n# Subscribe to each\nfor (node_id, obs) in observables\n    subscribe!(obs, lambda(on_next = x -> println(\"$node_id: $x\")))\nend","category":"page"},{"location":"rocket_integration/#Pattern-3:-Bidirectional-Pipeline","page":"Reactive Programming","title":"Pattern 3: Bidirectional Pipeline","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Use observable_through_dag() to create complete reactive pipelines.","category":"page"},{"location":"rocket_integration/#Basic-Example-3","page":"Reactive Programming","title":"Basic Example","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\ndag = StatDAG()\nadd_node!(dag, :raw, Mean())\nadd_node!(dag, :smoothed, Variance())\nconnect!(dag, :raw, :smoothed)\n\n# Input: noisy data stream\nnoisy_stream = from(randn(100))\n\n# Output: variance as observable\nvariance_obs = observable_through_dag(noisy_stream, dag, :raw, :smoothed)\n\n# Process reactive pipeline\nsubscribe!(variance_obs, logger())","category":"page"},{"location":"rocket_integration/#Real-World-Examples","page":"Reactive Programming","title":"Real-World Examples","text":"","category":"section"},{"location":"rocket_integration/#Example-1:-Real-time-Sensor-Processing","page":"Reactive Programming","title":"Example 1: Real-time Sensor Processing","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\n# Create DAG for multi-sensor processing\ndag = StatDAG()\nadd_node!(dag, :temp_sensor, Mean())\nadd_node!(dag, :pressure_sensor, Mean())\nadd_node!(dag, :humidity_sensor, Mean())\nadd_node!(dag, :alert_system, Mean())\n\nconnect!(dag, :temp_sensor, :alert_system, filter = t -> t > 80)\nconnect!(dag, :pressure_sensor, :alert_system, filter = p -> p < 900)\n\n# Create observable streams from sensors\ntemp_stream = interval(1000) |> map(Float64, _ -> 20 + 10 * randn())\npressure_stream = interval(1000) |> map(Float64, _ -> 1013 + 5 * randn())\nhumidity_stream = interval(1000) |> map(Float64, _ -> 50 + 10 * randn())\n\n# Connect streams to DAG\nsubscribe!(temp_stream, StatDAGActor(dag, :temp_sensor))\nsubscribe!(pressure_stream, StatDAGActor(dag, :pressure_sensor))\nsubscribe!(humidity_stream, StatDAGActor(dag, :humidity_sensor))\n\n# Monitor alerts\nalert_obs = to_observable(dag, :alert_system)\nsubscribe!(alert_obs, lambda(\n    on_next = x -> @warn \"Alert triggered! Value: $x\"\n))","category":"page"},{"location":"rocket_integration/#Example-2:-Financial-Market-Data-Stream","page":"Reactive Programming","title":"Example 2: Financial Market Data Stream","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"using OnlineStatsChains\nusing OnlineStats\nusing Rocket\n\n# DAG for technical indicators\ndag = StatDAG()\nadd_node!(dag, :price, Mean())\nadd_node!(dag, :sma_20, Mean())  # Simple moving average\nadd_node!(dag, :variance, Variance())  # Price variance\nadd_node!(dag, :extrema, Extrema())  # Min/max tracking\n\nconnect!(dag, :price, :sma_20)\nconnect!(dag, :price, :variance)\nconnect!(dag, :price, :extrema)\n\n# Market data stream (simulated)\nmarket_stream = interval(100) |> map(Float64, _ -> 100 + randn())\n\n# Feed into DAG and expose variance as observable\nsubscribe!(market_stream, StatDAGActor(dag, :price))\nvariance_signal = to_observable(dag, :variance)\n\n# Trading signal logic\nsubscribe!(variance_signal, lambda(\n    on_next = x -> begin\n        if x > 10\n            println(\"High volatility: Variance = $x\")\n        elseif x < 2\n            println(\"Low volatility: Variance = $x\")\n        end\n    end\n))","category":"page"},{"location":"rocket_integration/#API-Reference","page":"Reactive Programming","title":"API Reference","text":"","category":"section"},{"location":"rocket_integration/#StatDAGActor","page":"Reactive Programming","title":"StatDAGActor","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"StatDAGActor(dag::StatDAG, node_id::Symbol;\n             filter=nothing, transform=nothing)","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Actor that feeds incoming data from a Rocket.jl Observable into a StatDAG node.","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Arguments:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag::StatDAG: The DAG instance\nnode_id::Symbol: The target node identifier\nfilter::Union{Function, Nothing}: Optional filter function\ntransform::Union{Function, Nothing}: Optional transform function","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Methods:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"on_next!(actor, data): Handle incoming data\non_error!(actor, error): Handle errors\non_complete!(actor): Handle stream completion","category":"page"},{"location":"rocket_integration/#to_observable","page":"Reactive Programming","title":"to_observable","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"to_observable(dag::StatDAG, node_id::Symbol; emit=:computed)","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Convert a StatDAG node into a Rocket.jl Observable.","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Arguments:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag::StatDAG: The DAG instance\nnode_id::Symbol: The node to observe\nemit::Symbol: What to emit - :computed, :raw, or :both","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Returns:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"StatDAGObservable: An observable that emits node values","category":"page"},{"location":"rocket_integration/#to_observables","page":"Reactive Programming","title":"to_observables","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"to_observables(dag::StatDAG, node_ids::Vector{Symbol}; emit=:computed)","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Create multiple observables from DAG nodes.","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Arguments:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"dag::StatDAG: The DAG instance\nnode_ids::Vector{Symbol}: Vector of node IDs to observe\nemit::Symbol: What to emit - :computed, :raw, or :both","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Returns:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Dict{Symbol, StatDAGObservable}: Dictionary mapping node IDs to observables","category":"page"},{"location":"rocket_integration/#observable*through*dag","page":"Reactive Programming","title":"observablethroughdag","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"observable_through_dag(observable, dag::StatDAG,\n                       source_node::Symbol, sink_node::Symbol)","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Create a reactive pipeline: Observable → DAG → Observable","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Arguments:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"observable: Input Rocket.jl Observable\ndag::StatDAG: The DAG to process data through\nsource_node::Symbol: DAG node to receive input data\nsink_node::Symbol: DAG node to emit output from","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Returns:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"StatDAGObservable: Observable emitting processed results","category":"page"},{"location":"rocket_integration/#When-to-Use","page":"Reactive Programming","title":"When to Use","text":"","category":"section"},{"location":"rocket_integration/#Use-Pure-StatDAG-When:","page":"Reactive Programming","title":"Use Pure StatDAG When:","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Processing complete datasets (batch mode)\nSynchronous, deterministic workflows\nSimple linear or tree pipelines\nAll data is available upfront","category":"page"},{"location":"rocket_integration/#Use-StatDAG-Rocket.jl-When:","page":"Reactive Programming","title":"Use StatDAG + Rocket.jl When:","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Processing real-time event streams\nHandling asynchronous data sources\nBuilding reactive, event-driven systems\nDealing with multiple concurrent streams\nNeed time-based operations (windowing, throttling)","category":"page"},{"location":"rocket_integration/#Performance-Considerations","page":"Reactive Programming","title":"Performance Considerations","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Aspect Pure StatDAG StatDAG + Rocket.jl\nLatency Lowest (direct calls) Higher (event dispatch)\nThroughput Highest (batch mode) Good (streaming mode)\nMemory Lower Higher (buffering)\nCPU Lower overhead Additional dispatch cost\nScalability Limited by memory Better for streams","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Recommendation: Use Rocket.jl integration when you need reactive/async capabilities; stick with pure StatDAG for simpler batch processing.","category":"page"},{"location":"rocket_integration/#Troubleshooting","page":"Reactive Programming","title":"Troubleshooting","text":"","category":"section"},{"location":"rocket_integration/#Extension-Not-Loading","page":"Reactive Programming","title":"Extension Not Loading","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"If the Rocket.jl integration doesn't work:","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Ensure you're using Julia 1.10 or later\nCheck that Rocket.jl is installed: using Pkg; Pkg.status(\"Rocket\")\nLoad Rocket.jl before using integration functions: using Rocket\nCheck for errors: Base.get_extension(OnlineStatsChains, :OnlineStatsChainsRocketExt)","category":"page"},{"location":"rocket_integration/#Common-Errors","page":"Reactive Programming","title":"Common Errors","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"KeyError: Node doesn't exist","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"# Make sure to add nodes before creating actors/observables\nadd_node!(dag, :mynode, Mean())\nactor = StatDAGActor(dag, :mynode)  # OK","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"ArgumentError: Invalid emit type","category":"page"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"# Use only :computed, :raw, or :both\nobs = to_observable(dag, :node, emit=:computed)  # OK\nobs = to_observable(dag, :node, emit=:invalid)   # Error","category":"page"},{"location":"rocket_integration/#See-Also","page":"Reactive Programming","title":"See Also","text":"","category":"section"},{"location":"rocket_integration/","page":"Reactive Programming","title":"Reactive Programming","text":"Rocket.jl Documentation\nOnlineStatsChains.jl Basic Usage\nAPI Reference\nExamples","category":"page"},{"location":"quickstart/#Quick-Start-Guide","page":"Quick Start","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"This guide will get you up and running with OnlineStatsChains.jl in minutes.","category":"page"},{"location":"quickstart/#Basic-Workflow","page":"Quick Start","title":"Basic Workflow","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The typical workflow consists of four steps:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Create a DAG\nAdd nodes\nConnect nodes\nFit data","category":"page"},{"location":"quickstart/#Your-First-DAG","page":"Quick Start","title":"Your First DAG","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Step 1: Create a DAG\ndag = StatDAG()\n\n# Step 2: Add nodes with OnlineStats\nadd_node!(dag, :data, Mean())\nadd_node!(dag, :variance, Variance())\n\n# Step 3: Connect nodes\nconnect!(dag, :data, :variance)\n\n# Step 4: Fit data\nfor x in randn(100)\n    fit!(dag, :data => x)\nend\n\n# Get results\nprintln(\"Mean: \", value(dag, :data))\nprintln(\"Variance: \", value(dag, :variance))","category":"page"},{"location":"quickstart/#Batch-Processing","page":"Quick Start","title":"Batch Processing","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Process entire arrays at once:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :downstream, Mean())\nconnect!(dag, :source, :downstream)\n\n# Batch mode\ndata = randn(1000)\nfit!(dag, :source => data)\n\nprintln(\"Result: \", value(dag, :downstream))","category":"page"},{"location":"quickstart/#Evaluation-Strategies","page":"Quick Start","title":"Evaluation Strategies","text":"","category":"section"},{"location":"quickstart/#Eager-Evaluation-(Default)","page":"Quick Start","title":"Eager Evaluation (Default)","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Immediate propagation:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()  # Eager by default\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)  # Propagates to :b immediately\nvalue(dag, :b)  # Already computed","category":"page"},{"location":"quickstart/#Lazy-Evaluation","page":"Quick Start","title":"Lazy Evaluation","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Deferred computation:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG(strategy=:lazy)\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)  # No propagation\nvalue(dag, :b)  # Triggers computation","category":"page"},{"location":"quickstart/#Common-Patterns","page":"Quick Start","title":"Common Patterns","text":"","category":"section"},{"location":"quickstart/#Linear-Chain","page":"Quick Start","title":"Linear Chain","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :middle, Mean())\nadd_node!(dag, :sink, Mean())\n\nconnect!(dag, :source, :middle)\nconnect!(dag, :middle, :sink)\n\nfit!(dag, :source => randn(100))","category":"page"},{"location":"quickstart/#Fan-Out","page":"Quick Start","title":"Fan-Out","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"One source, multiple destinations:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :branch1, Variance())\nadd_node!(dag, :branch2, Extrema())\n\nconnect!(dag, :source, :branch1)\nconnect!(dag, :source, :branch2)\n\nfit!(dag, :source => randn(100))","category":"page"},{"location":"quickstart/#Fan-In","page":"Quick Start","title":"Fan-In","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Multiple sources, one destination:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :input1, Mean())\nadd_node!(dag, :input2, Mean())\nadd_node!(dag, :combined, Mean())\n\nconnect!(dag, [:input1, :input2], :combined)\n\nfit!(dag, Dict(\n    :input1 => randn(50),\n    :input2 => randn(50)\n))","category":"page"},{"location":"quickstart/#Edge-Transformations","page":"Quick Start","title":"Edge Transformations","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Transform data as it flows through the DAG:","category":"page"},{"location":"quickstart/#Basic-Transform","page":"Quick Start","title":"Basic Transform","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :celsius, Mean())\nadd_node!(dag, :fahrenheit, Mean())\n\n# Convert Celsius to Fahrenheit\nconnect!(dag, :celsius, :fahrenheit, transform = c -> c * 9/5 + 32)\n\nfit!(dag, :celsius => [0.0, 10.0, 20.0, 30.0])\nvalue(dag, :celsius)      # 15.0°C\nvalue(dag, :fahrenheit)   # 59.0°F","category":"page"},{"location":"quickstart/#Filtered-Transform","page":"Quick Start","title":"Filtered Transform","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Combine filters with transformations:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :raw, Mean())\nadd_node!(dag, :valid, Mean())\n\n# Only propagate non-missing values\nconnect!(dag, :raw, :valid, filter = !ismissing)\n\nfit!(dag, :raw => [1.0, missing, 2.0, 3.0])\nvalue(dag, :valid)  # 2.0 (only valid values)","category":"page"},{"location":"quickstart/#Data-Extraction","page":"Quick Start","title":"Data Extraction","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Extract fields from structured data:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"dag = StatDAG()\nadd_node!(dag, :transactions, Mean())\nadd_node!(dag, :prices, Mean())\n\n# Extract price from transaction\nconnect!(dag, :transactions, :prices, transform = t -> t.price)\n\ntransactions = [(price=10.0, qty=5), (price=15.0, qty=3)]\nfit!(dag, :transactions => transactions)\nvalue(dag, :prices)  # 12.5 (mean of prices)","category":"page"},{"location":"quickstart/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Basic Usage Tutorial - Learn fundamental concepts\nAdvanced Patterns - Complex DAG structures\nAPI Reference - Complete function documentation","category":"page"},{"location":"tutorials/advanced/#Advanced-Patterns","page":"Advanced Patterns","title":"Advanced Patterns","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"This tutorial covers advanced DAG patterns and techniques.","category":"page"},{"location":"tutorials/advanced/#Fan-Out-Pattern","page":"Advanced Patterns","title":"Fan-Out Pattern","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"One source feeding multiple downstream nodes.","category":"page"},{"location":"tutorials/advanced/#Basic-Fan-Out","page":"Advanced Patterns","title":"Basic Fan-Out","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\n# One source\nadd_node!(dag, :source, Mean())\n\n# Multiple destinations\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :extrema, Extrema())\nadd_node!(dag, :quantile, Quantile(0.95))\n\n# Connect one-to-many\nconnect!(dag, :source, :variance)\nconnect!(dag, :source, :extrema)\nconnect!(dag, :source, :quantile)\n\n# All downstream nodes receive updates\nfit!(dag, :source => randn(1000))","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Visualization:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"        ┌→ variance\nsource ─┼→ extrema\n        └→ quantile","category":"page"},{"location":"tutorials/advanced/#Fan-In-Pattern","page":"Advanced Patterns","title":"Fan-In Pattern","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Multiple sources feeding one destination.","category":"page"},{"location":"tutorials/advanced/#Basic-Fan-In","page":"Advanced Patterns","title":"Basic Fan-In","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG()\n\n# Multiple sources\nadd_node!(dag, :high, Mean())\nadd_node!(dag, :low, Mean())\n\n# One destination\nadd_node!(dag, :spread, Mean())\n\n# Connect many-to-one\nconnect!(dag, [:high, :low], :spread)\n\n# Synchronized update\nfit!(dag, Dict(\n    :high => [105.0, 107.0, 106.0],\n    :low => [98.0, 99.0, 100.0]\n))\n\nprintln(\"Spread: \", value(dag, :spread))","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Visualization:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"high ─┐\n      ├→ spread\nlow ──┘","category":"page"},{"location":"tutorials/advanced/#Custom-Multi-Input-Stats","page":"Advanced Patterns","title":"Custom Multi-Input Stats","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"For fan-in, the destination receives an array of parent values:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"# Custom stat that expects array input\nstruct SpreadStat <: OnlineStat{Vector{Float64}}\n    mean::Mean\nend\n\nSpreadStat() = SpreadStat(Mean())\n\nfunction OnlineStatsBase._fit!(s::SpreadStat, data::Vector)\n    # data = [high_value, low_value]\n    spread = data[1] - data[2]\n    fit!(s.mean, spread)\nend\n\nOnlineStatsBase.value(s::SpreadStat) = value(s.mean)\n\n# Use in DAG\ndag = StatDAG()\nadd_node!(dag, :high, Mean())\nadd_node!(dag, :low, Mean())\nadd_node!(dag, :spread, SpreadStat())\n\nconnect!(dag, [:high, :low], :spread)","category":"page"},{"location":"tutorials/advanced/#Diamond-Pattern","page":"Advanced Patterns","title":"Diamond Pattern","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Source splits and reconverges.","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG()\n\n# Source\nadd_node!(dag, :source, Mean())\n\n# Split\nadd_node!(dag, :path1, Mean())\nadd_node!(dag, :path2, Variance())\n\n# Reconverge\nadd_node!(dag, :sink, Mean())\n\n# Build diamond\nconnect!(dag, :source, :path1)\nconnect!(dag, :source, :path2)\nconnect!(dag, [:path1, :path2], :sink)\n\nfit!(dag, :source => randn(100))","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Visualization:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"         path1 ─┐\nsource ─┤       ├→ sink\n         path2 ─┘","category":"page"},{"location":"tutorials/advanced/#Layered-DAG","page":"Advanced Patterns","title":"Layered DAG","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Multiple processing stages:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG()\n\n# Input layer\nadd_node!(dag, :raw_data, Mean())\n\n# Processing layer\nadd_node!(dag, :normalized, Mean())\nadd_node!(dag, :smoothed, Mean())\n\n# Analysis layer\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :trend, Mean())\n\n# Connect layers\nconnect!(dag, :raw_data, :normalized)\nconnect!(dag, :normalized, :smoothed)\nconnect!(dag, :smoothed, :variance)\nconnect!(dag, :smoothed, :trend)","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Visualization:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"raw_data → normalized → smoothed ─┬→ variance\n                                  └→ trend","category":"page"},{"location":"tutorials/advanced/#Mixed-Batch-and-Streaming","page":"Advanced Patterns","title":"Mixed Batch and Streaming","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Combine different input modes:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG()\n\nadd_node!(dag, :stream, Mean())\nadd_node!(dag, :batch, Mean())\nadd_node!(dag, :combined, Mean())\n\nconnect!(dag, :stream, :combined)\nconnect!(dag, :batch, :combined)\n\n# Stream single values\nfor x in randn(10)\n    fit!(dag, :stream => x)\nend\n\n# Batch array\nfit!(dag, :batch => randn(100))","category":"page"},{"location":"tutorials/advanced/#Conditional-Processing","page":"Advanced Patterns","title":"Conditional Processing","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Use different strategies for different branches:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"# Main DAG with eager evaluation\ndag = StatDAG(strategy=:eager)\n\nadd_node!(dag, :realtime, Mean())\nadd_node!(dag, :analysis, Variance())\n\nconnect!(dag, :realtime, :analysis)\n\n# Realtime updates\nfit!(dag, :realtime => sensor_reading())\n\n# Switch to lazy for batch processing\nset_strategy!(dag, :lazy)\n\n# Batch updates don't propagate\nfit!(dag, :realtime => historical_data)\n\n# Trigger when ready\nvalue(dag, :analysis)","category":"page"},{"location":"tutorials/advanced/#Multi-Level-Aggregation","page":"Advanced Patterns","title":"Multi-Level Aggregation","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Hierarchical aggregation:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG()\n\n# Leaf level - individual sensors\nadd_node!(dag, :sensor1, Mean())\nadd_node!(dag, :sensor2, Mean())\nadd_node!(dag, :sensor3, Mean())\n\n# Mid level - zones\nadd_node!(dag, :zone1, Mean())\nadd_node!(dag, :zone2, Mean())\n\n# Top level - building\nadd_node!(dag, :building, Mean())\n\n# Build hierarchy\nconnect!(dag, [:sensor1, :sensor2], :zone1)\nconnect!(dag, :sensor3, :zone2)\nconnect!(dag, [:zone1, :zone2], :building)\n\n# Update sensors\nfit!(dag, Dict(\n    :sensor1 => [20.0, 21.0],\n    :sensor2 => [19.0, 20.0],\n    :sensor3 => [22.0, 23.0]\n))","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Visualization:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"sensor1 ─┐\n         ├→ zone1 ─┐\nsensor2 ─┘         │\n                   ├→ building\nsensor3 ─→ zone2 ──┘","category":"page"},{"location":"tutorials/advanced/#Time-Series-Pipeline","page":"Advanced Patterns","title":"Time-Series Pipeline","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Process time-series with multiple indicators:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\n# Price input\nadd_node!(dag, :price, Mean())\n\n# Technical indicators\nadd_node!(dag, :sma_short, Mean())  # Short SMA\nadd_node!(dag, :sma_long, Mean())   # Long SMA\nadd_node!(dag, :volatility, Variance())\n\n# Signals\nadd_node!(dag, :momentum, Mean())\n\n# Build pipeline\nconnect!(dag, :price, :sma_short)\nconnect!(dag, :price, :sma_long)\nconnect!(dag, :price, :volatility)\nconnect!(dag, [:sma_short, :sma_long], :momentum)\n\n# Process prices\nprices = [100.0, 102.0, 101.0, 103.0, 105.0, 104.0, 106.0]\nfit!(dag, :price => prices)\n\n# Get indicators\nprintln(\"Short SMA: \", value(dag, :sma_short))\nprintln(\"Long SMA: \", value(dag, :sma_long))\nprintln(\"Volatility: \", value(dag, :volatility))","category":"page"},{"location":"tutorials/advanced/#Dynamic-DAG-Construction","page":"Advanced Patterns","title":"Dynamic DAG Construction","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Build DAGs programmatically:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"function create_sensor_network(n_sensors::Int)\n    dag = StatDAG()\n\n    # Add sensor nodes\n    for i in 1:n_sensors\n        add_node!(dag, Symbol(\"sensor_\", i), Mean())\n    end\n\n    # Add aggregator\n    add_node!(dag, :aggregator, Mean())\n\n    # Connect all sensors to aggregator\n    sensor_ids = [Symbol(\"sensor_\", i) for i in 1:n_sensors]\n    connect!(dag, sensor_ids, :aggregator)\n\n    return dag\nend\n\n# Create network with 5 sensors\ndag = create_sensor_network(5)\n\n# Update all sensors\nsensor_data = Dict(\n    Symbol(\"sensor_\", i) => randn(10)\n    for i in 1:5\n)\nfit!(dag, sensor_data)","category":"page"},{"location":"tutorials/advanced/#Lazy-Evaluation-for-Large-Graphs","page":"Advanced Patterns","title":"Lazy Evaluation for Large Graphs","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Optimize large DAGs with lazy evaluation:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG(strategy=:lazy)\n\n# Build large graph\nfor i in 1:100\n    add_node!(dag, Symbol(\"node_\", i), Mean())\nend\n\n# Create connections\nfor i in 1:99\n    connect!(dag, Symbol(\"node_\", i), Symbol(\"node_\", i+1))\nend\n\n# Fit data (no propagation)\nfit!(dag, :node_1 => randn(1000))\n\n# Only compute what's needed\nvalue(dag, :node_100)  # Triggers computation of entire chain","category":"page"},{"location":"tutorials/advanced/#Manual-Invalidation","page":"Advanced Patterns","title":"Manual Invalidation","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Fine-grained control with lazy mode:","category":"page"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"dag = StatDAG(strategy=:lazy)\n\nadd_node!(dag, :input, Mean())\nadd_node!(dag, :output, Mean())\nconnect!(dag, :input, :output)\n\n# Initial computation\nfit!(dag, :input => 1.0)\nvalue(dag, :output)  # Computes\n\n# Invalidate manually\ninvalidate!(dag, :input)\n\n# Recompute when needed\nrecompute!(dag)","category":"page"},{"location":"tutorials/advanced/#Next-Steps","page":"Advanced Patterns","title":"Next Steps","text":"","category":"section"},{"location":"tutorials/advanced/","page":"Advanced Patterns","title":"Advanced Patterns","text":"Performance Guide - Optimization techniques\nAPI Reference - Complete documentation\nExamples - Real-world use cases","category":"page"},{"location":"ai-generated/#AI-Generated-Package-Important-Notice","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Package - Important Notice","text":"","category":"section"},{"location":"ai-generated/#Generation-Method","page":"⚠️ AI-Generated Notice","title":"Generation Method","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"OnlineStatsChains.jl v0.1.0 was entirely generated using Claude Code (Claude 3.5 Sonnet), an AI coding assistant from Anthropic.","category":"page"},{"location":"ai-generated/#What-This-Means","page":"⚠️ AI-Generated Notice","title":"What This Means","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"This package was created through:","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"AI-driven development from a detailed EARS specification\nAutomated code generation with human oversight\nAI-written tests using BDD methodology\nAI-generated documentation including all tutorials and examples","category":"page"},{"location":"ai-generated/#Important-Considerations","page":"⚠️ AI-Generated Notice","title":"⚠️ Important Considerations","text":"","category":"section"},{"location":"ai-generated/#Potential-Risks","page":"⚠️ AI-Generated Notice","title":"Potential Risks","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Users should be aware of the following considerations when using AI-generated code:","category":"page"},{"location":"ai-generated/#1.-**Code-Quality-and-Correctness**","page":"⚠️ AI-Generated Notice","title":"1. Code Quality & Correctness","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"✅ Mitigated by: 72 BDD tests, all passing\n⚠️ Risk: Edge cases may not be fully covered despite high test coverage\nRecommendation: Review critical paths and add application-specific tests","category":"page"},{"location":"ai-generated/#2.-**Security-Concerns**","page":"⚠️ AI-Generated Notice","title":"2. Security Concerns","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"✅ Mitigated by: No external dependencies beyond OnlineStatsBase.jl\n⚠️ Risk: AI-generated code may have subtle vulnerabilities\nRecommendation: Security audit before production use in sensitive contexts","category":"page"},{"location":"ai-generated/#3.-**Maintenance-and-Understanding**","page":"⚠️ AI-Generated Notice","title":"3. Maintenance & Understanding","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"✅ Mitigated by: Comprehensive documentation and clear code structure\n⚠️ Risk: Original developers may not have deep implementation knowledge\nRecommendation: Study the codebase thoroughly before modifications","category":"page"},{"location":"ai-generated/#4.-**Edge-Cases-and-Corner-Cases**","page":"⚠️ AI-Generated Notice","title":"4. Edge Cases & Corner Cases","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"✅ Mitigated by: BDD tests cover main scenarios\n⚠️ Risk: Unusual usage patterns may trigger unexpected behavior\nRecommendation: Test thoroughly in your specific use case","category":"page"},{"location":"ai-generated/#5.-**Performance-Characteristics**","page":"⚠️ AI-Generated Notice","title":"5. Performance Characteristics","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"✅ Mitigated by: Algorithms designed for O(V+E) complexity\n⚠️ Risk: Real-world performance may vary with specific data patterns\nRecommendation: Benchmark with your actual workload","category":"page"},{"location":"ai-generated/#6.-**API-Design**","page":"⚠️ AI-Generated Notice","title":"6. API Design","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"✅ Mitigated by: Based on detailed EARS specification\n⚠️ Risk: API may not follow all Julia community best practices\nRecommendation: Provide feedback if you find API inconsistencies","category":"page"},{"location":"ai-generated/#Verification-Steps-Taken","page":"⚠️ AI-Generated Notice","title":"🔍 Verification Steps Taken","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Despite being AI-generated, this package includes:","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Comprehensive Testing\n72 BDD-style tests (Given-When-Then)\n90% code coverage\nAll tests passing\nSpecification Compliance\n100% conformance to EARS specification\n48/48 high-priority requirements met\n33/33 medium-priority requirements met\nCode Review Checkpoints\nCycle detection algorithm (DFS) verified\nTopological sort (Kahn's algorithm) verified\nError handling reviewed\nPerformance complexity validated\nDocumentation Quality\nComplete API documentation\nThree detailed tutorials\nReal-world examples\nPerformance guide","category":"page"},{"location":"ai-generated/#Recommended-Due-Diligence","page":"⚠️ AI-Generated Notice","title":"✅ Recommended Due Diligence","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Before using this package in production, consider:","category":"page"},{"location":"ai-generated/#For-All-Users","page":"⚠️ AI-Generated Notice","title":"For All Users","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Read the documentation carefully\nRun the test suite (Pkg.test(\"OnlineStatsChains\"))\nReview the source code (only 729 lines - manageable)\nTest with your specific use case\nReport any issues on GitHub","category":"page"},{"location":"ai-generated/#For-Critical-Applications","page":"⚠️ AI-Generated Notice","title":"For Critical Applications","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Security audit of the codebase\nExtended testing beyond included tests\nPerformance benchmarking with real data\nCode review by Julia experts\nConsider forking for internal modifications","category":"page"},{"location":"ai-generated/#For-Contributors","page":"⚠️ AI-Generated Notice","title":"For Contributors","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Understand the architecture before contributing\nAdd tests for new features\nUpdate documentation accordingly\nFollow Julia best practices\nReview AI-generated code critically","category":"page"},{"location":"ai-generated/#Transparency-Metrics","page":"⚠️ AI-Generated Notice","title":"📊 Transparency Metrics","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Aspect Details\nGenerator Claude Code (Anthropic)\nModel Claude 3.5 Sonnet\nSpecification EARS format, ai and human-written\nHuman Review Continuous oversight during generation\nTest Coverage >90%\nLines of Code 729 (src) + 1,010 (tests)\nDocumentation 2,777 lines (AI-generated)","category":"page"},{"location":"ai-generated/#Community-Feedback","page":"⚠️ AI-Generated Notice","title":"🤝 Community Feedback","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"This package is an experiment in AI-assisted package development. We welcome:","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Bug reports - especially for edge cases\nPerformance feedback - real-world usage data\nCode review - suggestions for improvements\nBest practices - Julia community standards\nSecurity concerns - responsible disclosure","category":"page"},{"location":"ai-generated/#Ethical-Considerations","page":"⚠️ AI-Generated Notice","title":"📜 Ethical Considerations","text":"","category":"section"},{"location":"ai-generated/#Transparency","page":"⚠️ AI-Generated Notice","title":"Transparency","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"We believe in full transparency about AI-generated code. This notice ensures users can make informed decisions.","category":"page"},{"location":"ai-generated/#Responsibility","page":"⚠️ AI-Generated Notice","title":"Responsibility","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"While AI-generated, the package maintainer takes full responsibility for:","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Code quality and correctness\nSecurity vulnerabilities\nUser support and maintenance\nBug fixes and improvements","category":"page"},{"location":"ai-generated/#Attribution","page":"⚠️ AI-Generated Notice","title":"Attribution","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Code Generation: Claude Code (Anthropic)\nSpecification: Human-written EARS format\nTesting Methodology: BDD (Behavior-Driven Development)\nOversight: Continuous human review","category":"page"},{"location":"ai-generated/#Future-Development","page":"⚠️ AI-Generated Notice","title":"🔮 Future Development","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"As AI coding tools evolve, this package may serve as a case study for:","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"AI-generated package quality assessment\nBest practices for AI-assisted development\nTesting strategies for generated code\nDocumentation standards for AI tools","category":"page"},{"location":"ai-generated/#Legal-Notice","page":"⚠️ AI-Generated Notice","title":"⚖️ Legal Notice","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"This package is provided \"as is\" without warranty of any kind. Users assume all risks associated with using AI-generated code. See LICENSE for full terms.","category":"page"},{"location":"ai-generated/#Contact","page":"⚠️ AI-Generated Notice","title":"📞 Contact","text":"","category":"section"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"For questions, concerns, or feedback about the AI-generation process:","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"GitHub Issues: Report problems\nDiscussions: Ask questions\nSecurity: Responsible disclosure via private channels","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Remember: AI-generated code is a tool, not a replacement for human judgment. Always review, test, and validate before deploying to production.","category":"page"},{"location":"ai-generated/","page":"⚠️ AI-Generated Notice","title":"⚠️ AI-Generated Notice","text":"Last updated: 2025-10-03","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Real-world examples demonstrating OnlineStatsChains.jl.","category":"page"},{"location":"examples/#Financial-Time-Series-Analysis","page":"Examples","title":"Financial Time Series Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Track multiple technical indicators:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_trading_dag()\n    dag = StatDAG()\n\n    # Price input\n    add_node!(dag, :price, Mean())\n\n    # Technical indicators\n    add_node!(dag, :sma_5, Mean())\n    add_node!(dag, :sma_20, Mean())\n    add_node!(dag, :volatility, Variance())\n    add_node!(dag, :range, Extrema())\n\n    # Build pipeline\n    connect!(dag, :price, :sma_5)\n    connect!(dag, :price, :sma_20)\n    connect!(dag, :price, :volatility)\n    connect!(dag, :price, :range)\n\n    return dag\nend\n\n# Use the DAG\ndag = create_trading_dag()\n\n# Stream price data\nprices = [100.0, 102.0, 101.0, 103.0, 105.0, 104.0, 106.0, 108.0]\nfit!(dag, :price => prices)\n\n# Get indicators\nprintln(\"Price: \", value(dag, :price))\nprintln(\"SMA(5): \", value(dag, :sma_5))\nprintln(\"SMA(20): \", value(dag, :sma_20))\nprintln(\"Volatility: \", value(dag, :volatility))\nprintln(\"Range: \", value(dag, :range))","category":"page"},{"location":"examples/#Sensor-Network-Monitoring","page":"Examples","title":"Sensor Network Monitoring","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-sensor aggregation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_sensor_network()\n    dag = StatDAG()\n\n    # Individual sensors\n    add_node!(dag, :temp_1, Mean())\n    add_node!(dag, :temp_2, Mean())\n    add_node!(dag, :temp_3, Mean())\n\n    # Zone aggregates\n    add_node!(dag, :zone_avg, Mean())\n    add_node!(dag, :zone_var, Variance())\n\n    # Building-level stats\n    add_node!(dag, :building, Mean())\n\n    # Connect sensors to zones\n    connect!(dag, [:temp_1, :temp_2, :temp_3], :zone_avg)\n    connect!(dag, [:temp_1, :temp_2, :temp_3], :zone_var)\n\n    # Connect to building\n    connect!(dag, :zone_avg, :building)\n\n    return dag\nend\n\n# Monitor sensors\ndag = create_sensor_network()\n\n# Update sensors (different sample sizes)\nfit!(dag, Dict(\n    :temp_1 => [20.1, 20.3, 20.2],\n    :temp_2 => [19.8, 20.0, 19.9],\n    :temp_3 => [20.5, 20.7]\n))\n\nprintln(\"Zone average: \", value(dag, :zone_avg))\nprintln(\"Zone variance: \", value(dag, :zone_var))\nprintln(\"Building temp: \", value(dag, :building))","category":"page"},{"location":"examples/#Streaming-Data-Pipeline","page":"Examples","title":"Streaming Data Pipeline","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Process real-time data with lazy evaluation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_streaming_pipeline()\n    # Use lazy for efficiency\n    dag = StatDAG(strategy=:lazy)\n\n    # Raw data input\n    add_node!(dag, :raw, Mean())\n\n    # Processing stages\n    add_node!(dag, :filtered, Mean())\n    add_node!(dag, :normalized, Mean())\n\n    # Analytics\n    add_node!(dag, :stats, Variance())\n    add_node!(dag, :summary, Extrema())\n\n    # Build pipeline\n    connect!(dag, :raw, :filtered)\n    connect!(dag, :filtered, :normalized)\n    connect!(dag, :normalized, :stats)\n    connect!(dag, :normalized, :summary)\n\n    return dag\nend\n\n# Process stream\ndag = create_streaming_pipeline()\n\n# Accumulate data (no propagation in lazy mode)\nfor batch in data_stream\n    fit!(dag, :raw => batch)\nend\n\n# Trigger computation when needed\nstats_value = value(dag, :stats)\nsummary_value = value(dag, :summary)","category":"page"},{"location":"examples/#Quality-Control-System","page":"Examples","title":"Quality Control System","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-stage quality checks:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_qc_pipeline()\n    dag = StatDAG()\n\n    # Measurement inputs\n    add_node!(dag, :measurement, Mean())\n\n    # Quality metrics\n    add_node!(dag, :mean_check, Mean())\n    add_node!(dag, :variance_check, Variance())\n    add_node!(dag, :range_check, Extrema())\n\n    # Aggregate QC\n    add_node!(dag, :qc_status, Mean())\n\n    # Build pipeline\n    connect!(dag, :measurement, :mean_check)\n    connect!(dag, :measurement, :variance_check)\n    connect!(dag, :measurement, :range_check)\n    connect!(dag, [:mean_check, :variance_check, :range_check], :qc_status)\n\n    return dag\nend\n\n# Run quality control\ndag = create_qc_pipeline()\n\nmeasurements = [10.1, 10.2, 10.15, 10.3, 10.25]\nfit!(dag, :measurement => measurements)\n\nprintln(\"Mean: \", value(dag, :mean_check))\nprintln(\"Variance: \", value(dag, :variance_check))\nprintln(\"Range: \", value(dag, :range_check))\nprintln(\"QC Status: \", value(dag, :qc_status))","category":"page"},{"location":"examples/#Real-Time-Dashboard","page":"Examples","title":"Real-Time Dashboard","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Live statistics update:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_dashboard()\n    dag = StatDAG(strategy=:eager)\n\n    # Data source\n    add_node!(dag, :events, Mean())\n\n    # Dashboard panels\n    add_node!(dag, :count_panel, Sum())\n    add_node!(dag, :avg_panel, Mean())\n    add_node!(dag, :var_panel, Variance())\n    add_node!(dag, :hist_panel, Hist(10))\n\n    # Connect to all panels\n    connect!(dag, :events, :count_panel)\n    connect!(dag, :events, :avg_panel)\n    connect!(dag, :events, :var_panel)\n    connect!(dag, :events, :hist_panel)\n\n    return dag\nend\n\n# Update dashboard\ndag = create_dashboard()\n\n# Stream events\nfunction update_dashboard(dag, event_value)\n    fit!(dag, :events => event_value)\n\n    # Dashboard auto-updates (eager mode)\n    return (\n        count = value(dag, :count_panel),\n        average = value(dag, :avg_panel),\n        variance = value(dag, :var_panel),\n        histogram = value(dag, :hist_panel)\n    )\nend\n\n# Simulate events\nfor event in event_stream\n    dashboard_data = update_dashboard(dag, event)\n    display_dashboard(dashboard_data)\nend","category":"page"},{"location":"examples/#Batch-Analytics-Pipeline","page":"Examples","title":"Batch Analytics Pipeline","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Process large datasets efficiently:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_analytics_pipeline()\n    dag = StatDAG(strategy=:lazy)\n\n    # Data inputs\n    add_node!(dag, :dataset_a, Mean())\n    add_node!(dag, :dataset_b, Mean())\n\n    # Derived metrics\n    add_node!(dag, :metric_1, Mean())\n    add_node!(dag, :metric_2, Variance())\n\n    # Final reports\n    add_node!(dag, :report_summary, Mean())\n\n    # Build pipeline\n    connect!(dag, :dataset_a, :metric_1)\n    connect!(dag, :dataset_b, :metric_1)\n    connect!(dag, [:dataset_a, :dataset_b], :metric_2)\n    connect!(dag, [:metric_1, :metric_2], :report_summary)\n\n    return dag\nend\n\n# Process batch\ndag = create_analytics_pipeline()\n\n# Load large datasets\ndata_a = load_dataset(\"a.csv\")\ndata_b = load_dataset(\"b.csv\")\n\n# Fit (lazy - no propagation)\nfit!(dag, Dict(\n    :dataset_a => data_a,\n    :dataset_b => data_b\n))\n\n# Compute only what's needed\nreport = value(dag, :report_summary)","category":"page"},{"location":"examples/#Multi-Source-Data-Fusion","page":"Examples","title":"Multi-Source Data Fusion","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Combine multiple data sources:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\nfunction create_fusion_pipeline()\n    dag = StatDAG()\n\n    # Multiple data sources\n    add_node!(dag, :sensor_a, Mean())\n    add_node!(dag, :sensor_b, Mean())\n    add_node!(dag, :database, Mean())\n\n    # Fusion layers\n    add_node!(dag, :fused_sensors, Mean())\n    add_node!(dag, :final_estimate, Mean())\n\n    # Build fusion\n    connect!(dag, [:sensor_a, :sensor_b], :fused_sensors)\n    connect!(dag, [:fused_sensors, :database], :final_estimate)\n\n    return dag\nend\n\n# Fuse data\ndag = create_fusion_pipeline()\n\nfit!(dag, Dict(\n    :sensor_a => [10.1, 10.2],\n    :sensor_b => [10.15, 10.25],\n    :database => [10.0, 10.1, 10.2]\n))\n\nprintln(\"Fused estimate: \", value(dag, :final_estimate))","category":"page"},{"location":"examples/#Strategy-Switching-Example","page":"Examples","title":"Strategy Switching Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Dynamic strategy changes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG(strategy=:eager)\n\nadd_node!(dag, :input, Mean())\nadd_node!(dag, :output, Mean())\nconnect!(dag, :input, :output)\n\n# Real-time mode (eager)\nprintln(\"Real-time processing...\")\nfor x in realtime_stream\n    fit!(dag, :input => x)\n    display(value(dag, :output))\nend\n\n# Switch to batch mode (lazy)\nprintln(\"Switching to batch mode...\")\nset_strategy!(dag, :lazy)\n\n# Process batch (no propagation)\nfit!(dag, :input => batch_data)\n\n# Compute when ready\nresult = value(dag, :output)","category":"page"},{"location":"examples/#Edge-Transformations","page":"Examples","title":"Edge Transformations","text":"","category":"section"},{"location":"examples/#Temperature-Conversion","page":"Examples","title":"Temperature Conversion","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Convert temperature units on-the-fly:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\n# Sensor outputs in Celsius\nadd_node!(dag, :celsius, Mean())\nadd_node!(dag, :fahrenheit, Mean())\nadd_node!(dag, :kelvin, Mean())\n\n# Convert to different scales\nconnect!(dag, :celsius, :fahrenheit, transform = c -> c * 9/5 + 32)\nconnect!(dag, :celsius, :kelvin, transform = c -> c + 273.15)\n\n# Input temperature readings\nfit!(dag, :celsius => [0.0, 10.0, 20.0, 30.0, 40.0])\n\nprintln(\"Celsius: \", value(dag, :celsius))       # 20.0°C\nprintln(\"Fahrenheit: \", value(dag, :fahrenheit)) # 68.0°F\nprintln(\"Kelvin: \", value(dag, :kelvin))         # 293.15K","category":"page"},{"location":"examples/#Data-Cleaning-Pipeline","page":"Examples","title":"Data Cleaning Pipeline","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Filter and transform data:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :raw_sensor, Mean())\nadd_node!(dag, :valid_only, Mean())\nadd_node!(dag, :calibrated, Mean())\n\n# Filter out missing values\nconnect!(dag, :raw_sensor, :valid_only, filter = !ismissing)\n\n# Apply calibration after filtering\nconnect!(dag, :valid_only, :calibrated, transform = x -> x * 1.05 + 0.5)\n\n# Input with some missing values\nfit!(dag, :raw_sensor => [10.0, missing, 15.0, missing, 20.0])\n\nprintln(\"Valid readings: \", value(dag, :valid_only))    # 15.0\nprintln(\"Calibrated: \", value(dag, :calibrated))        # 16.25","category":"page"},{"location":"examples/#E-Commerce-Analytics","page":"Examples","title":"E-Commerce Analytics","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Extract metrics from transaction data:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Transaction structure\nstruct Transaction\n    price::Float64\n    quantity::Int\n    discount::Float64\nend\n\ndag = StatDAG()\n\nadd_node!(dag, :transactions, Mean())\nadd_node!(dag, :avg_price, Mean())\nadd_node!(dag, :avg_quantity, Mean())\nadd_node!(dag, :total_revenue, Mean())\n\n# Extract different metrics\nconnect!(dag, :transactions, :avg_price, \n         transform = t -> t.price)\n\nconnect!(dag, :transactions, :avg_quantity, \n         transform = t -> Float64(t.quantity))\n\nconnect!(dag, :transactions, :total_revenue, \n         transform = t -> t.price * t.quantity * (1 - t.discount))\n\n# Process transactions\ntransactions = [\n    Transaction(100.0, 2, 0.1),\n    Transaction(150.0, 1, 0.0),\n    Transaction(75.0, 3, 0.2)\n]\n\nfit!(dag, :transactions => transactions)\n\nprintln(\"Average price: \", value(dag, :avg_price))\nprintln(\"Average quantity: \", value(dag, :avg_quantity))\nprintln(\"Average revenue: \", value(dag, :total_revenue))","category":"page"},{"location":"examples/#Conditional-Routing-with-Transforms","page":"Examples","title":"Conditional Routing with Transforms","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Route data based on conditions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :temperature, Mean())\nadd_node!(dag, :high_alert, Mean())\nadd_node!(dag, :normal, Mean())\nadd_node!(dag, :low_alert, Mean())\n\n# High temperature alert (>30°C) - convert to Fahrenheit\nconnect!(dag, :temperature, :high_alert,\n         filter = t -> t > 30,\n         transform = t -> t * 9/5 + 32)\n\n# Normal range (10-30°C) - keep as is\nconnect!(dag, :temperature, :normal,\n         filter = t -> 10 <= t <= 30)\n\n# Low temperature alert (<10°C) - flag with negative\nconnect!(dag, :temperature, :low_alert,\n         filter = t -> t < 10,\n         transform = t -> -t)\n\n# Stream temperature data\nfit!(dag, :temperature => [5.0, 15.0, 25.0, 35.0, 8.0, 32.0])\n\nprintln(\"High alerts (°F): \", value(dag, :high_alert))  # Avg of 95°F, 89.6°F\nprintln(\"Normal temps: \", value(dag, :normal))          # Avg of 15, 25\nprintln(\"Low alerts: \", value(dag, :low_alert))         # Avg of -5, -8","category":"page"},{"location":"examples/#Multi-Input-Feature-Engineering","page":"Examples","title":"Multi-Input Feature Engineering","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Combine multiple inputs with transformations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :price, Mean())\nadd_node!(dag, :volume, Mean())\nadd_node!(dag, :momentum, Mean())\n\n# Calculate momentum: price * volume\nconnect!(dag, [:price, :volume], :momentum,\n         transform = inputs -> inputs[1] * inputs[2])\n\n# Update with coordinated data\nfit!(dag, Dict(\n    :price => [100.0, 105.0, 103.0],\n    :volume => [1000.0, 1200.0, 900.0]\n))\n\nprintln(\"Average price: \", value(dag, :price))\nprintln(\"Average volume: \", value(dag, :volume))\nprintln(\"Average momentum: \", value(dag, :momentum))","category":"page"},{"location":"examples/#Log-Transform-Pipeline","page":"Examples","title":"Log Transform Pipeline","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Apply logarithmic transformations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\ndag = StatDAG()\n\nadd_node!(dag, :population, Mean())\nadd_node!(dag, :log_population, Mean())\nadd_node!(dag, :growth_rate, Mean())\n\n# Log transform\nconnect!(dag, :population, :log_population,\n         transform = p -> log10(p))\n\n# Calculate growth rate (only for positive changes)\nconnect!(dag, :log_population, :growth_rate,\n         filter = x -> x > 0)\n\n# Population data\nfit!(dag, :population => [1000.0, 1100.0, 1210.0, 1331.0])\n\nprintln(\"Mean population: \", value(dag, :population))\nprintln(\"Mean log(pop): \", value(dag, :log_population))\nprintln(\"Growth rate: \", value(dag, :growth_rate))","category":"page"},{"location":"examples/#See-Also","page":"Examples","title":"See Also","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Basic Tutorial - Fundamental concepts\nAdvanced Patterns - Complex structures\nPerformance Guide - Optimization\nAPI Reference - Complete documentation","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Requirements","page":"Installation","title":"Requirements","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.10 or later\nOnlineStatsBase.jl","category":"page"},{"location":"installation/#Installing-from-Package-Registry","page":"Installation","title":"Installing from Package Registry","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Once registered, install OnlineStatsChains.jl using Julia's package manager:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"OnlineStatsChains\")","category":"page"},{"location":"installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the development version:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.develop(url=\"https://github.com/femtotrader/OnlineStatsChains.jl\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Or from a local path:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.develop(path=\"/path/to/OnlineStatsChains\")","category":"page"},{"location":"installation/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Test that the package is correctly installed:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Create a simple DAG\ndag = StatDAG()\nadd_node!(dag, :test, Mean())\nfit!(dag, :test => 1.0)\n\nprintln(\"Installation successful! Value: \", value(dag, :test))","category":"page"},{"location":"installation/#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"OnlineStatsChains.jl depends on:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"OnlineStatsBase.jl - Provides the base OnlineStat types","category":"page"},{"location":"installation/#Optional-Dependencies","page":"Installation","title":"Optional Dependencies","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"For documentation:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Documenter.jl","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"For testing:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Test (Julia standard library)","category":"page"},{"location":"installation/#Compatibility","page":"Installation","title":"Compatibility","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia: 1.10+\nOnlineStatsBase: 1.x","category":"page"},{"location":"installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"installation/#Common-Issues","page":"Installation","title":"Common Issues","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Issue: Package not found Solution: Make sure you're using Julia 1.10 or later and have an up-to-date package registry.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update()\nPkg.add(\"OnlineStatsChains\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Issue: Method errors with OnlineStats Solution: Ensure you have compatible versions of OnlineStatsBase.jl installed.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.status(\"OnlineStatsBase\")","category":"page"},{"location":"installation/#Getting-Help","page":"Installation","title":"Getting Help","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you encounter issues:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Check the GitHub Issues\nRead the FAQ\nAsk on Julia Discourse","category":"page"},{"location":"tutorials/basic/#Basic-Usage-Tutorial","page":"Basic Usage","title":"Basic Usage Tutorial","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"This tutorial covers the fundamental concepts of OnlineStatsChains.jl.","category":"page"},{"location":"tutorials/basic/#Understanding-DAGs","page":"Basic Usage","title":"Understanding DAGs","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"A Directed Acyclic Graph (DAG) is a graph with directed edges and no cycles. In OnlineStatsChains:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Nodes contain OnlineStats\nEdges define data flow direction\nNo cycles ensures predictable execution order","category":"page"},{"location":"tutorials/basic/#Creating-Your-First-DAG","page":"Basic Usage","title":"Creating Your First DAG","text":"","category":"section"},{"location":"tutorials/basic/#Step-1:-Import-Packages","page":"Basic Usage","title":"Step 1: Import Packages","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"using OnlineStatsChains\nusing OnlineStatsBase  # For Mean, Variance, etc.","category":"page"},{"location":"tutorials/basic/#Step-2:-Create-a-DAG","page":"Basic Usage","title":"Step 2: Create a DAG","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG()","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"You can also specify an evaluation strategy:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG(strategy=:eager)   # Default\ndag = StatDAG(strategy=:lazy)    # Lazy evaluation\ndag = StatDAG(strategy=:partial) # Partial evaluation","category":"page"},{"location":"tutorials/basic/#Step-3:-Add-Nodes","page":"Basic Usage","title":"Step 3: Add Nodes","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Each node wraps an OnlineStat:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"add_node!(dag, :source, Mean())\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :extrema, Extrema())","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Node IDs must be unique Symbols:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"add_node!(dag, :node1, Mean())  # ✓ OK\nadd_node!(dag, :node1, Mean())  # ✗ Error: already exists","category":"page"},{"location":"tutorials/basic/#Step-4:-Connect-Nodes","page":"Basic Usage","title":"Step 4: Connect Nodes","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Create directed edges between nodes:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"connect!(dag, :source, :variance)\nconnect!(dag, :source, :extrema)","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"This creates the graph:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"source → variance\n   ↓\nextrema","category":"page"},{"location":"tutorials/basic/#Step-5:-Fit-Data","page":"Basic Usage","title":"Step 5: Fit Data","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Feed data to source nodes:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"# Single value\nfit!(dag, :source => 1.0)\nfit!(dag, :source => 2.0)\n\n# Batch (array)\nfit!(dag, :source => [3.0, 4.0, 5.0])","category":"page"},{"location":"tutorials/basic/#Step-6:-Retrieve-Values","page":"Basic Usage","title":"Step 6: Retrieve Values","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Get computed statistics:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"println(\"Mean: \", value(dag, :source))\nprintln(\"Variance: \", value(dag, :variance))\nprintln(\"Extrema: \", value(dag, :extrema))","category":"page"},{"location":"tutorials/basic/#Data-Flow-Modes","page":"Basic Usage","title":"Data Flow Modes","text":"","category":"section"},{"location":"tutorials/basic/#Streaming-Mode","page":"Basic Usage","title":"Streaming Mode","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Process one value at a time:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG()\nadd_node!(dag, :stream, Mean())\n\nfor x in randn(1000)\n    fit!(dag, :stream => x)\nend\n\nprintln(\"Streaming mean: \", value(dag, :stream))","category":"page"},{"location":"tutorials/basic/#Batch-Mode","page":"Basic Usage","title":"Batch Mode","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Process entire arrays:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG()\nadd_node!(dag, :batch, Mean())\n\ndata = randn(1000)\nfit!(dag, :batch => data)\n\nprintln(\"Batch mean: \", value(dag, :batch))","category":"page"},{"location":"tutorials/basic/#Evaluation-Strategies","page":"Basic Usage","title":"Evaluation Strategies","text":"","category":"section"},{"location":"tutorials/basic/#Eager-Evaluation","page":"Basic Usage","title":"Eager Evaluation","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Default behavior - propagates immediately:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG(strategy=:eager)\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)\n# :b is immediately updated\n\nvalue(dag, :b)  # Already computed","category":"page"},{"location":"tutorials/basic/#Lazy-Evaluation","page":"Basic Usage","title":"Lazy Evaluation","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Defers computation until needed:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG(strategy=:lazy)\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nconnect!(dag, :a, :b)\n\nfit!(dag, :a => 1.0)\n# :b is NOT updated yet\n\nvalue(dag, :b)  # Triggers computation NOW","category":"page"},{"location":"tutorials/basic/#Switching-Strategies","page":"Basic Usage","title":"Switching Strategies","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Change strategy dynamically:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG(strategy=:eager)\n# ... use dag ...\n\nset_strategy!(dag, :lazy)\n# Now uses lazy evaluation","category":"page"},{"location":"tutorials/basic/#Working-with-Multiple-Sources","page":"Basic Usage","title":"Working with Multiple Sources","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Update multiple source nodes:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"dag = StatDAG()\nadd_node!(dag, :input1, Mean())\nadd_node!(dag, :input2, Mean())\nadd_node!(dag, :output, Mean())\n\nconnect!(dag, :input1, :output)\nconnect!(dag, :input2, :output)\n\n# Update both sources\nfit!(dag, Dict(\n    :input1 => 10.0,\n    :input2 => 20.0\n))","category":"page"},{"location":"tutorials/basic/#Error-Handling","page":"Basic Usage","title":"Error Handling","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"OnlineStatsChains provides clear error messages:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"# Duplicate node\nadd_node!(dag, :test, Mean())\nadd_node!(dag, :test, Mean())\n# Error: ArgumentError: Node :test already exists\n\n# Non-existent node\nconnect!(dag, :a, :nonexistent)\n# Error: ArgumentError: Node :nonexistent does not exist\n\n# Cycle detection\nadd_node!(dag, :a, Mean())\nadd_node!(dag, :b, Mean())\nadd_node!(dag, :c, Mean())\nconnect!(dag, :a, :b)\nconnect!(dag, :b, :c)\nconnect!(dag, :c, :a)\n# Error: CycleError: Adding edge :c -> :a would create a cycle","category":"page"},{"location":"tutorials/basic/#Introspection","page":"Basic Usage","title":"Introspection","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Examine your DAG structure:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"# List all nodes\nnodes = get_nodes(dag)\n\n# Get node relationships\nparents = get_parents(dag, :node_id)\nchildren = get_children(dag, :node_id)\n\n# Get execution order\norder = get_topological_order(dag)\n\n# Validate DAG\nvalidate(dag)  # Returns true if valid","category":"page"},{"location":"tutorials/basic/#Complete-Example","page":"Basic Usage","title":"Complete Example","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Putting it all together:","category":"page"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Create DAG\ndag = StatDAG()\n\n# Build structure\nadd_node!(dag, :prices, Mean())\nadd_node!(dag, :variance, Variance())\nadd_node!(dag, :range, Extrema())\n\nconnect!(dag, :prices, :variance)\nconnect!(dag, :prices, :range)\n\n# Process data\nprices = [100.0, 102.0, 101.0, 103.0, 105.0]\nfit!(dag, :prices => prices)\n\n# Results\nprintln(\"Average price: \", value(dag, :prices))\nprintln(\"Price variance: \", value(dag, :variance))\nprintln(\"Price range: \", value(dag, :range))","category":"page"},{"location":"tutorials/basic/#Next-Steps","page":"Basic Usage","title":"Next Steps","text":"","category":"section"},{"location":"tutorials/basic/","page":"Basic Usage","title":"Basic Usage","text":"Advanced Patterns - Complex DAG structures\nPerformance Guide - Optimization techniques\nAPI Reference - Complete documentation","category":"page"},{"location":"#OnlineStatsChains.jl-Documentation","page":"Home","title":"OnlineStatsChains.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: AI-Generated Package\nThis package was entirely generated using Claude Code (AI).Please read the ⚠️ AI-Generated Notice carefully before using in production.While the package includes comprehensive tests and documentation, users should:Review the code for their use case\nAdd application-specific tests\nReport any issues foundSee the full notice for security considerations and recommended due diligence.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package for chaining OnlineStats computations in a Directed Acyclic Graph (DAG) structure with automatic value propagation.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OnlineStatsChains.jl provides a powerful framework for building computational pipelines where OnlineStats are automatically updated as data flows through a directed acyclic graph.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📊 DAG Construction: Build computational graphs with automatic cycle detection\n⚡ Three Evaluation Strategies:\nEager (default): Immediate propagation when fit!() is called\nLazy: Deferred computation until value() is requested\nPartial: Optimized propagation for affected subgraphs only\n🔀 Multi-Input Nodes: Support for fan-in and fan-out patterns\n📈 Batch & Streaming: Process data element-by-element or in batches\n🔧 Type-Safe: Works with any OnlineStat from OnlineStatsBase.jl","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OnlineStatsChains\nusing OnlineStatsBase\n\n# Create a computational DAG\ndag = StatDAG()\n\n# Add nodes\nadd_node!(dag, :source, Mean())\nadd_node!(dag, :variance, Variance())\n\n# Connect nodes\nconnect!(dag, :source, :variance)\n\n# Fit data (propagates automatically)\nfit!(dag, :source => [1.0, 2.0, 3.0, 4.0, 5.0])\n\n# Get results\nprintln(\"Mean: \", value(dag, :source))       # 3.0\nprintln(\"Variance: \", value(dag, :variance))","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"installation.md\",\n    \"quickstart.md\",\n    \"tutorials/basic.md\",\n    \"tutorials/advanced.md\",\n    \"tutorials/performance.md\",\n    \"api.md\",\n    \"examples.md\",\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
